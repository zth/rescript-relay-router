#!/usr/bin/env node
import * as Caml_option from 'rescript/lib/es6/caml_option.js';
import * as Caml_js_exceptions from 'rescript/lib/es6/caml_js_exceptions.js';
import * as Fs from 'fs';
import * as Path from 'path';
import * as Js_exn from 'rescript/lib/es6/js_exn.js';
import * as Caml_exceptions from 'rescript/lib/es6/caml_exceptions.js';
import FastGlob from 'fast-glob';
import * as FastFuzzy from 'fast-fuzzy';
import * as JsoncParser$1 from 'jsonc-parser';
import * as LinesAndColumns from 'lines-and-columns';
import * as $$Crypto from 'crypto';
import * as Cosmiconfig from 'cosmiconfig';
import * as Url from 'url';
import Chokidar from 'chokidar';
import * as VscodeJsonrpc from 'vscode-jsonrpc';
import * as MessagesJs from 'vscode-jsonrpc/lib/messages.js';
import * as Caml_obj from 'rescript/lib/es6/caml_obj.js';
import * as Os from 'os';
import * as Child_process from 'child_process';
import Chalk from 'chalk';

// Generated by ReScript, PLEASE EDIT WITH CARE


function reduce(arr, init, f) {
  return arr.reduce(f, init);
}

function filterMap$1(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    var v$1 = f(v);
    if (v$1 !== undefined) {
      r[j] = Caml_option.valFromOption(v$1);
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function forEach(opt, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  }
  
}

function flatMap(opt, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  }
  
}

function getOr(opt, $$default) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    return $$default;
  }
}

function isSome(x) {
  return x !== undefined;
}

function isNone(x) {
  return x === undefined;
}
/* No side effect */

/**
MIT License

Copyright (c) React Training 2015-2019 Copyright (c) Remix Software 2020-2022

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// RescriptRelayRouter note:
// Inlined + modified from https://github.com/remix-run/react-router/blob/main/packages/router/router.ts

/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */
function matchRoutes(routes, locationArg, basename = "/") {
  let location =
    typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(
      branches[i],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(
  routes,
  branches = [],
  parentsMeta = [],
  parentPath = ""
) {
  routes.forEach((route, index) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route,
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path ` +
          `"${parentPath}" is not valid. An absolute child route path ` +
          `must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove ` +
          `all child routes from route path "${path}".`
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({ path, score: computeScore(path, route.index), routesMeta });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) =>
    a.score !== b.score
      ? b.score - a.score // Higher score first
      : compareIndexes(
          a.routesMeta.map((meta) => meta.childrenIndex),
          b.routesMeta.map((meta) => meta.childrenIndex)
        )
  );
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const regexSegmentValue = 7;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments
    .filter((s) => !isSplat(s))
    .reduce((score, segment) => {
      let scoreToAdd = 0;
      if (paramRe.test(segment)) {
        // Means regexp segment
        if (segment.endsWith(")")) {
          scoreToAdd = regexSegmentValue;
        } else {
          scoreToAdd = dynamicSegmentValue;
        }
      } else {
        if (segment === "") {
          scoreToAdd = emptySegmentValue;
        } else {
          scoreToAdd = staticSegmentValue;
        }
      }

      return score + scoreToAdd;
    }, initialScore);
}
function compareIndexes(a, b) {
  let siblings =
    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings
    ? // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a[a.length - 1] - b[b.length - 1]
    : // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0;
}
function matchRouteBranch(branch, pathname) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname =
      matchedPathname === "/"
        ? pathname
        : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname
    );
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase])
      ),
      route,
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, paramNames] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname
        .slice(0, matchedPathname.length - splatValue.length)
        .replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(
      captureGroups[index] || "",
      paramName
    );
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern,
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were ` +
      `"${path.replace(/\*$/, "/*")}" because the \`*\` character must ` +
      `always follow a \`/\` in the pattern. To get rid of this warning, ` +
      `please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let paramNames = [];
  let regexpSource =
    "^" +
    path
      .replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
      .replace(/^\/*/, "/") // Make sure it has a leading /
      .replace(/[\\.*+^$?{}[\]]/g, "\\$&") // Escape special regex chars
      .replace(/:([\w(|)-]+)/g, (_, paramName) => {
        // Check if this is a regexp param. If so, special treatment.
        if (paramName.endsWith(")")) {
          let [pname, regexp] = paramName.slice(0, -1).split("(");
          paramNames.push(pname);
          return `(${regexp})`;
        }
        paramNames.push(paramName);
        return "([^\\/]+)";
      });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource +=
      path === "*" || path === "/*"
        ? "(.*)$" // Already matched the initial /, just match the rest
        : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is is a ` +
        `malformed URL segment. This is probably due to a bad percent ` +
        `encoding (${error}).`
    );
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(
      false,
      `The value for the URL param "${paramName}" will not be decoded because` +
        ` the string "${value}" is a malformed URL segment. This is probably` +
        ` due to a bad percent encoding (${error}).`
    );
    return value;
  }
}
/**
 * @private
 */
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it
  let startIndex = basename.endsWith("/")
    ? basename.length - 1
    : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
/**
 * @private
 */
function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message);
      // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
/**
 * @private
 */
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */
const normalizePathname = (pathname) =>
  pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

// Generated by ReScript, PLEASE EDIT WITH CARE


function copyAuxCont(_cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return prec;
    }
    var next = {
      hd: cellX.hd,
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue ;
  }}

function copyAuxWitFilter(f, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (f(h)) {
      var next = {
        hd: h,
        tl: /* [] */0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _cellX = t;
    continue ;
  }}

function copyAuxWitFilterMap(f, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = f(cellX.hd);
    if (h !== undefined) {
      var next = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _cellX = t;
    continue ;
  }}

function copyAuxWithMap(_cellX, _prec, f) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var next = {
      hd: f(cellX.hd),
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue ;
  }}

function concat(xs, ys) {
  if (!xs) {
    return ys;
  }
  var cell = {
    hd: xs.hd,
    tl: /* [] */0
  };
  copyAuxCont(xs.tl, cell).tl = ys;
  return cell;
}

function map(xs, f) {
  if (!xs) {
    return /* [] */0;
  }
  var cell = {
    hd: f(xs.hd),
    tl: /* [] */0
  };
  copyAuxWithMap(xs.tl, cell, f);
  return cell;
}

function length(xs) {
  var _x = xs;
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var x = _x;
    if (!x) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _x = x.tl;
    continue ;
  }}

function fillAux(arr, _i, _x) {
  while(true) {
    var x = _x;
    var i = _i;
    if (!x) {
      return ;
    }
    arr[i] = x.hd;
    _x = x.tl;
    _i = i + 1 | 0;
    continue ;
  }}

function fromArray(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  }}

function toArray(x) {
  var len = length(x);
  var arr = new Array(len);
  fillAux(arr, 0, x);
  return arr;
}

function reverseConcat(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue ;
  }}

function reverse(l) {
  return reverseConcat(l, /* [] */0);
}

function concatMany(xs) {
  var len = xs.length;
  if (len === 1) {
    return xs[0];
  }
  if (len === 0) {
    return /* [] */0;
  }
  var len$1 = xs.length;
  var v = xs[len$1 - 1 | 0];
  for(var i = len$1 - 2 | 0; i >= 0; --i){
    v = concat(xs[i], v);
  }
  return v;
}

function has(_xs, x, eq) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd, x)) {
      return true;
    }
    _xs = xs.tl;
    continue ;
  }}

function find(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var x = xs.hd;
    if (p(x)) {
      return Caml_option.some(x);
    }
    _xs = xs.tl;
    continue ;
  }}

function filter(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var t = xs.tl;
    var h = xs.hd;
    if (p(h)) {
      var cell = {
        hd: h,
        tl: /* [] */0
      };
      copyAuxWitFilter(p, t, cell);
      return cell;
    }
    _xs = t;
    continue ;
  }}

function filterMap(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var t = xs.tl;
    var h = p(xs.hd);
    if (h !== undefined) {
      var cell = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */0
      };
      copyAuxWitFilterMap(p, t, cell);
      return cell;
    }
    _xs = t;
    continue ;
  }}
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function make$6(routeNamePath, loc) {
  return {
          routeNamePath: routeNamePath,
          loc: loc
        };
}

function getRouteName(t) {
  return getOr(toArray(t.routeNamePath).pop(), "");
}

function getFullRouteName(t) {
  return toArray(t.routeNamePath).join("__");
}

function getFullRouteAccessPath(t) {
  return toArray(t.routeNamePath).join(".") + ".Route";
}

function getRouteRendererName(t) {
  return getFullRouteName(t) + "_route_renderer";
}

function getRouteRendererFileName(t) {
  return getRouteRendererName(t) + ".res";
}

function toGeneratedRouteModuleName(t) {
  return "Route__" + getFullRouteName(t) + "_route";
}

function getLoc(t) {
  return t.loc;
}

var RouteName = {
  make: make$6,
  getRouteName: getRouteName,
  getFullRouteName: getFullRouteName,
  getFullRouteAccessPath: getFullRouteAccessPath,
  getRouteRendererName: getRouteRendererName,
  getRouteRendererFileName: getRouteRendererFileName,
  toGeneratedRouteModuleName: toGeneratedRouteModuleName,
  getLoc: getLoc
};

function cleanPathParamTypeAnnotations(p) {
  if (p.includes(":", 1)) {
    return ":" + getOr(p.slice(1).split(":")[0], "");
  } else {
    return p;
  }
}

function make$1$2(path, currentRoutePath) {
  var cleanPath = getOr(path.split("?")[0], "");
  return {
          pathSegment: cleanPath,
          currentRoutePath: map(filter(concat(reverse(fromArray(cleanPath.split("/"))), currentRoutePath.currentRoutePath), (function (urlPart) {
                      return urlPart !== "";
                    })), (function (p) {
                  return cleanPathParamTypeAnnotations(p);
                }))
        };
}

function getPathSegment(t) {
  return t.pathSegment.split("/").map(function (p) {
                return cleanPathParamTypeAnnotations(p);
              }).join("/");
}

function getFullRoutePath(t) {
  return "/" + toArray(reverse(t.currentRoutePath)).join("/");
}

function toPattern(t) {
  return "/" + toArray(filterMap(reverse(t.currentRoutePath), (function (part) {
                      if (part === "/") {
                        return ;
                      } else {
                        return part;
                      }
                    }))).join("/");
}

function empty() {
  return {
          pathSegment: "",
          currentRoutePath: /* [] */0
        };
}

var RoutePath = {
  make: make$1$2,
  getPathSegment: getPathSegment,
  getFullRoutePath: getFullRoutePath,
  toPattern: toPattern,
  empty: empty
};
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function decodeParseErrorCode(code) {
  switch (code) {
    case 1 :
        return "InvalidSymbol";
    case 2 :
        return "InvalidNumberFormat";
    case 3 :
        return "PropertyNameExpected";
    case 4 :
        return "ValueExpected";
    case 5 :
        return "ColonExpected";
    case 6 :
        return "CommaExpected";
    case 7 :
        return "CloseBraceExpected";
    case 8 :
        return "CloseBracketExpected";
    case 9 :
        return "EndOfFileExpected";
    case 10 :
        return "InvalidCommentToken";
    case 11 :
        return "UnexpectedEndOfComment";
    case 12 :
        return "UnexpectedEndOfString";
    case 13 :
        return "UnexpectedEndOfNumber";
    case 14 :
        return "InvalidUnicode";
    case 15 :
        return "InvalidEscapeCharacter";
    case 16 :
        return "InvalidCharacter";
    default:
      return ;
  }
}

function nodeToString(node) {
  switch (node.TAG) {
    case "Object" :
        return "object";
    case "Array" :
        return "array";
    case "Boolean" :
        return "boolean(" + (
                node.value ? "true" : "false"
              ) + "})";
    case "String" :
        return "string(\"" + node.value + "\")";
    case "Number" :
        return "number(" + node.value.toString() + ")";
    case "Null" :
        return "null";
    
  }
}
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function pathInRoutesFolder$1(config, fileNameOpt) {
  var fileName = fileNameOpt !== undefined ? fileNameOpt : "";
  return Path.join(config.routesFolderPath, fileName);
}

function stringToQueryParam(str) {
  if (str.startsWith("array<")) {
    var arrayValue = str.replace("array<", "");
    var arrayValue$1 = arrayValue.slice(0, arrayValue.length - 1 | 0);
    var value = stringToQueryParam(arrayValue$1);
    if (value.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: {
                TAG: "Array",
                _0: value._0
              }
            };
    } else {
      return value;
    }
  }
  switch (str) {
    case "bool" :
        return {
                TAG: "Ok",
                _0: "Boolean"
              };
    case "float" :
        return {
                TAG: "Ok",
                _0: "Float"
              };
    case "int" :
        return {
                TAG: "Ok",
                _0: "Int"
              };
    case "string" :
        return {
                TAG: "Ok",
                _0: "String"
              };
    default:
      var required = str.endsWith("!");
      var maybeCustomModule = required ? str.replace("!", "") : str;
      var firstChar = maybeCustomModule.charAt(0);
      var correctEnding = maybeCustomModule.endsWith(".t");
      if (!correctEnding) {
        return {
                TAG: "Error",
                _0: undefined
              };
      }
      var match = firstChar.toUpperCase();
      if (firstChar === "" || firstChar !== match) {
        return {
                TAG: "Error",
                _0: undefined
              };
      } else {
        return {
                TAG: "Ok",
                _0: {
                  TAG: "CustomModule",
                  moduleName: maybeCustomModule.slice(0, maybeCustomModule.length - 2 | 0),
                  required: required
                }
              };
      }
  }
}

function rangeFromNode(node, lineLookup) {
  return {
          start: lineLookup.locationForIndex(node.offset),
          end_: lineLookup.locationForIndex(node.offset + node.length | 0)
        };
}

function transformNode(node, ctx) {
  var loc = rangeFromNode(node, ctx.lineLookup);
  var match = node.type;
  var match$1 = node.value;
  var match$2 = node.children;
  if (match === "null") {
    return {
            TAG: "Null",
            loc: loc,
            error: undefined
          };
  }
  if (match === "boolean") {
    if (match$1 !== undefined && !(!Array.isArray(match$1) && (match$1 === null || typeof match$1 !== "object") && typeof match$1 !== "number" && typeof match$1 !== "string" && typeof match$1 !== "boolean" || typeof match$1 !== "boolean")) {
      return {
              TAG: "Boolean",
              loc: loc,
              error: undefined,
              value: match$1
            };
    } else {
      return ;
    }
  }
  if (match === "string") {
    if (match$1 !== undefined && !(!Array.isArray(match$1) && (match$1 === null || typeof match$1 !== "object") && typeof match$1 !== "number" && typeof match$1 !== "string" && typeof match$1 !== "boolean" || typeof match$1 !== "string")) {
      return {
              TAG: "String",
              loc: loc,
              error: undefined,
              value: match$1
            };
    } else {
      return ;
    }
  }
  if (match !== "object") {
    if (match === "number") {
      if (match$1 !== undefined && !(!Array.isArray(match$1) && (match$1 === null || typeof match$1 !== "object") && typeof match$1 !== "number" && typeof match$1 !== "string" && typeof match$1 !== "boolean" || typeof match$1 !== "number")) {
        return {
                TAG: "Number",
                loc: loc,
                error: undefined,
                value: match$1
              };
      } else {
        return ;
      }
    } else if (match === "array" && match$2 !== undefined) {
      return {
              TAG: "Array",
              loc: loc,
              error: undefined,
              children: filterMap$1(match$2, (function (child) {
                      return transformNode(child, ctx);
                    }))
            };
    } else {
      return ;
    }
  }
  if (match$2 === undefined) {
    return ;
  }
  var properties = [];
  return {
          TAG: "Object",
          loc: loc,
          error: undefined,
          properties: (match$2.forEach(function (child) {
                  var match = child.type;
                  var match$1 = child.children;
                  if (match !== "property") {
                    return ;
                  }
                  if (match$1 === undefined) {
                    return ;
                  }
                  if (match$1.length !== 2) {
                    return ;
                  }
                  var match$2 = match$1[0];
                  if (match$2.type !== "string") {
                    return ;
                  }
                  var name = match$2.value;
                  if (name === undefined) {
                    return ;
                  }
                  var rawValue = match$1[1];
                  var match$3 = transformNode(rawValue, ctx);
                  if (!Array.isArray(name) && (name === null || typeof name !== "object") && typeof name !== "number" && typeof name !== "string" && typeof name !== "boolean" || !(typeof name === "string" && match$3 !== undefined)) {
                    return ;
                  } else {
                    properties.push({
                          loc: rangeFromNode(child, ctx.lineLookup),
                          name: name,
                          value: match$3
                        });
                    return ;
                  }
                }), properties)
        };
}

var dummyPos$1 = {
  start: {
    line: 0,
    column: 0
  },
  end_: {
    line: 0,
    column: 0
  }
};

function withoutQueryParams(path) {
  return getOr(path.split("?")[0], "");
}

function decodePathParams(path, loc, lineNum, ctx, parentContext) {
  var pathWithoutQueryParams = withoutQueryParams(path);
  var foundPathParams = [];
  var currentContext;
  var startCharIdx = loc.start.column + 1 | 0;
  var addParamIfNotAlreadyPresent = function (currentCtx, paramLoc) {
    var alreadySeenPathParam = find(parentContext.seenPathParams, (function (param) {
            var match = param.seenAtPosition;
            return match.text.text === currentCtx.paramName;
          }));
    if (alreadySeenPathParam !== undefined) {
      if (alreadySeenPathParam.seenInSourceFile === ctx.routeFileName) {
        return ctx.addDecodeError(paramLoc, "Path parameter \"" + currentCtx.paramName + "\" already exists in route \"" + alreadySeenPathParam.seenInSourceFile + "\". Path parameters cannot appear more than once per full path.");
      } else {
        return ctx.addDecodeError(paramLoc, "Path parameter \"" + currentCtx.paramName + "\" already exists in file \"" + alreadySeenPathParam.seenInSourceFile + "\" (route with name \"" + alreadySeenPathParam.seenInSourceFile + "\"), which is a parent to this route. Path names need to be unique per full route, including parents/children.");
      }
    }
    var textNode_loc = {
      start: {
        line: lineNum,
        column: currentCtx.startChar
      },
      end_: {
        line: lineNum,
        column: path.length - 1 | 0
      }
    };
    var textNode_text = currentCtx.paramName;
    var textNode = {
      loc: textNode_loc,
      text: textNode_text
    };
    foundPathParams.push(currentCtx.matchBranches.length > 0 ? ({
              TAG: "PathParamWithMatchBranches",
              text: textNode,
              matchArms: currentCtx.matchBranches
            }) : (
            currentCtx.currentParamCustomType.length > 0 ? ({
                  TAG: "PathParam",
                  text: textNode,
                  pathToCustomModuleWithTypeT: currentCtx.currentParamCustomType
                }) : ({
                  TAG: "PathParam",
                  text: textNode
                })
          ));
  };
  for(var charIdx = 0 ,charIdx_finish = pathWithoutQueryParams.length; charIdx < charIdx_finish; ++charIdx){
    var charLoc_start = {
      line: lineNum,
      column: startCharIdx + charIdx | 0
    };
    var charLoc_end_ = {
      line: lineNum,
      column: (startCharIdx + charIdx | 0) + 1 | 0
    };
    var charLoc = {
      start: charLoc_start,
      end_: charLoc_end_
    };
    var match = currentContext;
    var match$1 = getOr(pathWithoutQueryParams[charIdx], "");
    if (match !== undefined) {
      if (match$1 === "/") {
        if (match.paramName.length === 0) {
          ctx.addDecodeError({
                start: {
                  line: lineNum,
                  column: (startCharIdx + charIdx | 0) - 1 | 0
                },
                end_: {
                  line: lineNum,
                  column: startCharIdx + charIdx | 0
                }
              }, "Path parameter names cannot be empty.");
        }
        var paramLoc_start = {
          line: lineNum,
          column: match.startChar
        };
        var paramLoc_end_ = {
          line: lineNum,
          column: (startCharIdx + charIdx | 0) - 1 | 0
        };
        var paramLoc = {
          start: paramLoc_start,
          end_: paramLoc_end_
        };
        addParamIfNotAlreadyPresent(match, paramLoc);
        currentContext = undefined;
      } else {
        switch (match.inContext) {
          case "ParamName" :
              var exit = 0;
              switch (match$1) {
                case "(" :
                    currentContext = {
                      startChar: match.startChar,
                      endChar: match.endChar,
                      paramName: match.paramName,
                      inContext: "MatchBranches",
                      currentParamCustomType: match.currentParamCustomType,
                      currentMatchParam: match.currentMatchParam,
                      matchBranches: match.matchBranches
                    };
                    break;
                case ":" :
                    if (match.paramName.length > 0) {
                      currentContext = {
                        startChar: match.startChar,
                        endChar: match.endChar,
                        paramName: match.paramName,
                        inContext: "ParamCustomType",
                        currentParamCustomType: match.currentParamCustomType,
                        currentMatchParam: match.currentMatchParam,
                        matchBranches: match.matchBranches
                      };
                    } else {
                      exit = 1;
                    }
                    break;
                default:
                  exit = 1;
              }
              if (exit === 1) {
                currentContext = {
                  startChar: match.startChar,
                  endChar: match.endChar,
                  paramName: match.paramName + match$1,
                  inContext: match.inContext,
                  currentParamCustomType: match.currentParamCustomType,
                  currentMatchParam: match.currentMatchParam,
                  matchBranches: match.matchBranches
                };
                var match$2 = match.paramName.length;
                if (match$2 !== 0) {
                  if (/[A-Za-z0-9_]/.test(match$1)) ; else {
                    ctx.addDecodeError(charLoc, "\"" + match$1 + "\" is not a valid character in a path parameter. Path parameters can contain letters, digits, dots and underscores.");
                  }
                } else if (/[a-z]/.test(match$1)) ; else {
                  ctx.addDecodeError(charLoc, "Path parameters must start with a lowercase letter.");
                }
              }
              break;
          case "ParamCustomType" :
              currentContext = {
                startChar: match.startChar,
                endChar: match.endChar,
                paramName: match.paramName,
                inContext: match.inContext,
                currentParamCustomType: match.currentParamCustomType + match$1,
                currentMatchParam: match.currentMatchParam,
                matchBranches: match.matchBranches
              };
              var match$3 = match.paramName.length;
              if (match$3 !== 0) {
                if (/[A-Za-z0-9_\.]/.test(match$1)) ; else {
                  ctx.addDecodeError(charLoc, "\"" + match$1 + "\" is not a valid character in a path parameter. Path parameters can contain letters, digits, dots and underscores.");
                }
              } else if (/[A-Z]/.test(match$1)) ; else {
                ctx.addDecodeError(charLoc, "Path parameter type references must refer to a module, and therefore must start with an uppercase letter.");
              }
              break;
          case "MatchBranches" :
              var exit$1 = 0;
              switch (match$1) {
                case ")" :
                case "|" :
                    exit$1 = 1;
                    break;
                default:
                  currentContext = {
                    startChar: match.startChar,
                    endChar: match.endChar,
                    paramName: match.paramName,
                    inContext: match.inContext,
                    currentParamCustomType: match.currentParamCustomType,
                    currentMatchParam: match.currentMatchParam + match$1,
                    matchBranches: match.matchBranches
                  };
                  var match$4 = match.currentMatchParam.length;
                  if (match$4 !== 0) {
                    if (/[A-Za-z0-9_\-]/.test(match$1)) ; else {
                      ctx.addDecodeError(charLoc, "\"" + match$1 + "\" is not a valid character in a path match branch. Path match branches can contain letters, digits, underscores and hyphens.");
                    }
                  } else if (/[a-zA-Z]/.test(match$1)) ; else {
                    ctx.addDecodeError(charLoc, "Path param match branches must start with a letter.");
                  }
              }
              if (exit$1 === 1) {
                currentContext = {
                  startChar: match.startChar,
                  endChar: match.endChar,
                  paramName: match.paramName,
                  inContext: match.inContext,
                  currentParamCustomType: match.currentParamCustomType,
                  currentMatchParam: "",
                  matchBranches: match.matchBranches.concat([match.currentMatchParam])
                };
              }
              break;
          
        }
      }
    } else if (match$1 === ":") {
      currentContext = {
        startChar: startCharIdx + charIdx | 0,
        endChar: undefined,
        paramName: "",
        inContext: "ParamName",
        currentParamCustomType: "",
        currentMatchParam: "",
        matchBranches: []
      };
    }
    
  }
  var currentCtx = currentContext;
  if (currentCtx !== undefined) {
    var currentParamCustomType = currentCtx.currentParamCustomType;
    if (currentParamCustomType.length > 0 && !currentParamCustomType.endsWith(".t")) {
      ctx.addDecodeError({
            start: {
              line: lineNum,
              column: currentCtx.startChar
            },
            end_: {
              line: lineNum,
              column: startCharIdx + pathWithoutQueryParams.length | 0
            }
          }, "Custom path parameters type annotations must refer to a type t in a module, hence end with \".t\".");
    } else {
      var paramLoc_start$1 = {
        line: lineNum,
        column: currentCtx.startChar
      };
      var paramLoc_end_$1 = {
        line: lineNum,
        column: startCharIdx + pathWithoutQueryParams.length | 0
      };
      var paramLoc$1 = {
        start: paramLoc_start$1,
        end_: paramLoc_end_$1
      };
      addParamIfNotAlreadyPresent(currentCtx, paramLoc$1);
    }
  }
  return foundPathParams;
}

var queryParamNames = [
  "string",
  "int",
  "float",
  "bool",
  "array"
];

function handleCompletedParam(completedParamCtx, ctx, foundQueryParams, lineNum) {
  var keyEndChar = completedParamCtx.keyEndChar;
  if (keyEndChar === undefined) {
    return ;
  }
  var typeStartChar = completedParamCtx.typeStartChar;
  if (typeStartChar === undefined) {
    return ;
  }
  var typeEndChar = completedParamCtx.typeEndChar;
  if (typeEndChar === undefined) {
    return ;
  }
  var rawTypeText = completedParamCtx.rawTypeText;
  if (rawTypeText === undefined) {
    return ;
  }
  var queryParamLoc_start = {
    line: lineNum,
    column: typeStartChar
  };
  var queryParamLoc_end_ = {
    line: lineNum,
    column: typeEndChar
  };
  var queryParamLoc = {
    start: queryParamLoc_start,
    end_: queryParamLoc_end_
  };
  var keyLoc_start = {
    line: lineNum,
    column: completedParamCtx.keyStartChar
  };
  var keyLoc_end_ = {
    line: lineNum,
    column: keyEndChar
  };
  var keyLoc = {
    start: keyLoc_start,
    end_: keyLoc_end_
  };
  var queryParam = stringToQueryParam(rawTypeText);
  if (queryParam.TAG === "Ok") {
    foundQueryParams.push({
          name: {
            loc: keyLoc,
            text: completedParamCtx.key
          },
          queryParam: [
            queryParamLoc,
            queryParam._0
          ]
        });
    return ;
  }
  var fuzzyMatches = FastFuzzy.search(rawTypeText, queryParamNames);
  var message = "\"" + rawTypeText + "\" is not a valid query param type.\n  " + (
    fuzzyMatches.length > 0 ? "Did you mean \"" + fuzzyMatches[0] + "\"?" : (
        rawTypeText === "boolean" ? "Did you mean \"bool\"?" : "Valid types are: string, int, float, bool, custom modules (SomeModule.t), and arrays of those."
      )
  );
  ctx.addDecodeError(queryParamLoc, message);
}

function decodeQueryParams(path, loc, lineNum, ctx, parentContext) {
  var queryParamsStr = path.split("?").pop();
  if (queryParamsStr === undefined) {
    return [];
  }
  var startChar = ((loc.start.column + path.length | 0) - queryParamsStr.length | 0) + 1 | 0;
  var foundQueryParams = [];
  var context;
  for(var charIdx = 0 ,charIdx_finish = queryParamsStr.length; charIdx < charIdx_finish; ++charIdx){
    var $$char = getOr(queryParamsStr[charIdx], "");
    var match = context;
    if (match !== undefined) {
      var rawTypeText = match.rawTypeText;
      switch ($$char) {
        case "&" :
            handleCompletedParam({
                  keyStartChar: match.keyStartChar,
                  keyEndChar: match.keyEndChar,
                  typeStartChar: match.typeStartChar,
                  typeEndChar: startChar + charIdx | 0,
                  key: match.key,
                  rawTypeText: match.rawTypeText
                }, ctx, foundQueryParams, lineNum);
            context = undefined;
            break;
        case "=" :
            context = {
              keyStartChar: match.keyStartChar,
              keyEndChar: (startChar + charIdx | 0) - 1 | 0,
              typeStartChar: (startChar + charIdx | 0) + 1 | 0,
              typeEndChar: match.typeEndChar,
              key: match.key,
              rawTypeText: ""
            };
            break;
        default:
          context = rawTypeText !== undefined ? ({
                keyStartChar: match.keyStartChar,
                keyEndChar: match.keyEndChar,
                typeStartChar: match.typeStartChar,
                typeEndChar: match.typeEndChar,
                key: match.key,
                rawTypeText: rawTypeText + $$char
              }) : ({
                keyStartChar: match.keyStartChar,
                keyEndChar: match.keyEndChar,
                typeStartChar: match.typeStartChar,
                typeEndChar: match.typeEndChar,
                key: match.key + $$char,
                rawTypeText: match.rawTypeText
              });
      }
    } else {
      context = {
        keyStartChar: startChar + charIdx | 0,
        keyEndChar: undefined,
        typeStartChar: undefined,
        typeEndChar: undefined,
        key: $$char,
        rawTypeText: undefined
      };
    }
  }
  var completedParamCtx = context;
  if (completedParamCtx !== undefined) {
    handleCompletedParam({
          keyStartChar: completedParamCtx.keyStartChar,
          keyEndChar: completedParamCtx.keyEndChar,
          typeStartChar: completedParamCtx.typeStartChar,
          typeEndChar: loc.end_.column - 1 | 0,
          key: completedParamCtx.key,
          rawTypeText: completedParamCtx.rawTypeText
        }, ctx, foundQueryParams, lineNum);
  }
  var queryParamsResult = [];
  parentContext.seenQueryParams.concat(foundQueryParams).forEach(function (param) {
        if (queryParamsResult.some(function (p) {
                return p.name.text === param.name.text;
              })) {
          return ;
        } else {
          queryParamsResult.push(param);
          return ;
        }
      });
  return queryParamsResult;
}

function routeWithNameAlreadyExists(existingChildren, routeName) {
  return existingChildren.some(function (child) {
              if (child.TAG === "Include") {
                return routeWithNameAlreadyExists(child._0.content, routeName);
              } else {
                return RouteName.getRouteName(child._0.name) === routeName;
              }
            });
}

function validateName(nameNode, ctx, siblings) {
  if (nameNode === undefined) {
    return ;
  }
  var node = nameNode.value;
  var loc = nameNode.loc;
  if (node.TAG === "String") {
    var value = node.value;
    var loc$1 = node.loc;
    if (value === "Route") {
      ctx.addDecodeError(loc$1, "\"Route\" is a reserved name. Please change your route name to something else.");
      return {
              loc: loc$1,
              name: "_"
            };
    }
    var match = /^[A-Z][a-zA-Z0-9_]+$/.test(value);
    var match$1 = routeWithNameAlreadyExists(siblings, value);
    if (match) {
      if (match$1) {
        ctx.addDecodeError(loc$1, "Duplicate route \"" + value + "\". Routes cannot have siblings with the same names.");
        return {
                loc: loc$1,
                name: "_"
              };
      } else {
        return {
                loc: loc$1,
                name: value
              };
      }
    } else {
      ctx.addDecodeError(loc$1, "\"" + value + "\" is not a valid route name. Route names need to start with an uppercase letter, and can only contain letters, digits and underscores.");
      return {
              loc: loc$1,
              name: "_"
            };
    }
  }
  ctx.addDecodeError(loc, "\"name\" needs to be a string. Found " + nodeToString(node) + ".");
  return {
          loc: loc,
          name: "_"
        };
}

function validatePath(pathNode, ctx, parentContext) {
  if (pathNode === undefined) {
    return ;
  }
  var node = pathNode.value;
  var loc = pathNode.loc;
  if (node.TAG === "String") {
    var value = node.value;
    var pathValueLoc = node.loc;
    return {
            loc: loc,
            pathRaw: value,
            queryParams: decodeQueryParams(value, pathValueLoc, loc.start.line, ctx, parentContext),
            pathParams: decodePathParams(value, pathValueLoc, loc.start.line, ctx, parentContext)
          };
  }
  ctx.addDecodeError(loc, "\"path\" needs to be a string. Found " + nodeToString(node) + ".");
  return {
          loc: loc,
          pathRaw: "_",
          queryParams: [],
          pathParams: []
        };
}

function findPropertyWithName(properties, name) {
  return properties.find(function (prop) {
              return prop.name === name;
            });
}

function decodeRouteChildren(children, ctx, parentContext) {
  var foundChildren = [];
  children.forEach(function (child) {
        var decoded = decodeRouteChild(child, ctx, foundChildren, parentContext);
        if (decoded.TAG === "Ok") {
          var routeChild = decoded._0;
          foundChildren.push(routeChild);
          if (routeChild.TAG === "Include") {
            return ;
          }
          var routeEntry = routeChild._0;
          parentContext.routesByName[RouteName.getFullRouteName(routeEntry.name)] = routeEntry;
          return ;
        }
        var parseError = decoded._0;
        ctx.addDecodeError(parseError.loc, parseError.message);
      });
  return foundChildren;
}

function decodeRouteChild(child, ctx, siblings, parentContext) {
  if (child.TAG !== "Object") {
    return {
            TAG: "Error",
            _0: {
              routeFileName: ctx.routeFileName,
              message: "Routes must be objects. Found " + nodeToString(child) + ".",
              loc: child.loc
            }
          };
  }
  var properties = child.properties;
  var objLoc = child.loc;
  var includeProp = findPropertyWithName(properties, "include");
  if (includeProp !== undefined) {
    var keyLoc = includeProp.loc;
    if (includeProp.name === "include") {
      var match = includeProp.value;
      if (match.TAG === "String") {
        var fileName = match.value;
        var valueLoc = match.loc;
        properties.forEach(function (prop) {
              if (prop.name !== "include") {
                return ctx.addDecodeError(prop.loc, "Property \"" + prop.name + "\" is not allowed together with \"include\".");
              }
              
            });
        var errorRecoveryIncludeNode = {
          TAG: "Include",
          _0: {
            loc: objLoc,
            keyLoc: keyLoc,
            fileName: {
              loc: valueLoc,
              text: fileName
            },
            content: [],
            parentRouteFiles: toArray(parentContext.traversedRouteFiles),
            parentRouteLoc: parentContext.parentRouteLoc
          }
        };
        if (fileName.endsWith(".json")) {
          var message = ctx.getRouteFile(fileName, parentContext);
          if (message.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Include",
                      _0: {
                        loc: objLoc,
                        keyLoc: keyLoc,
                        fileName: {
                          loc: valueLoc,
                          text: fileName
                        },
                        content: message._0.content,
                        parentRouteFiles: toArray(parentContext.traversedRouteFiles),
                        parentRouteLoc: parentContext.parentRouteLoc
                      }
                    }
                  };
          }
          ctx.addDecodeError(objLoc, message._0);
          return {
                  TAG: "Ok",
                  _0: errorRecoveryIncludeNode
                };
        }
        ctx.addDecodeError(valueLoc, "Route file to include must have .json extension.");
        return {
                TAG: "Ok",
                _0: errorRecoveryIncludeNode
              };
      }
      
    }
    
  }
  var pathProp = findPropertyWithName(properties, "path");
  var nameProp = findPropertyWithName(properties, "name");
  var children = findPropertyWithName(properties, "children");
  var name = validateName(nameProp, ctx, siblings);
  var path = validatePath(pathProp, ctx, parentContext);
  var pathParams;
  if (path !== undefined) {
    var params = [];
    path.pathParams.concat(toArray(map(parentContext.seenPathParams, (function (param) {
                      return param.seenAtPosition;
                    })))).forEach(function (param) {
          if (params.includes(param)) {
            return ;
          } else {
            params.push(param);
            return ;
          }
        });
    pathParams = params;
  } else {
    pathParams = [];
  }
  if (path === undefined) {
    if (name !== undefined) {
      ctx.addDecodeError(objLoc, "This route entry is missing the \"path\" prop.");
      return {
              TAG: "Ok",
              _0: {
                TAG: "RouteEntry",
                _0: {
                  loc: objLoc,
                  name: RouteName.make({
                        hd: "_",
                        tl: /* [] */0
                      }, name.loc),
                  path: {
                    loc: dummyPos$1,
                    text: "_"
                  },
                  routePath: RoutePath.empty(),
                  pathParams: pathParams,
                  queryParams: [],
                  children: undefined,
                  sourceFile: ctx.routeFileName,
                  parentRouteFiles: toArray(parentContext.traversedRouteFiles),
                  parentRouteLoc: parentContext.parentRouteLoc
                }
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: {
                routeFileName: ctx.routeFileName,
                message: "Invalid route entry found.",
                loc: objLoc
              }
            };
    }
  }
  if (name !== undefined) {
    var thisRouteNamePath_0 = name.name;
    var thisRouteNamePath_1 = parentContext.currentRouteNamePath;
    var thisRouteNamePath = {
      hd: thisRouteNamePath_0,
      tl: thisRouteNamePath_1
    };
    var routePath = RoutePath.make(path.pathRaw, parentContext.currentRoutePath);
    var children$1;
    if (children !== undefined) {
      var match$1 = children.value;
      children$1 = match$1.TAG === "Array" ? decodeRouteChildren(match$1.children, ctx, {
              seenQueryParams: path.queryParams,
              currentRoutePath: routePath,
              currentRouteNamePath: thisRouteNamePath,
              seenPathParams: concatMany([
                    parentContext.seenPathParams,
                    map(fromArray(path.pathParams), (function (pathParam) {
                            return {
                                    seenInSourceFile: ctx.routeFileName,
                                    seenAtPosition: pathParam
                                  };
                          }))
                  ]),
              traversedRouteFiles: parentContext.traversedRouteFiles,
              parentRouteLoc: {
                childrenArray: match$1.loc
              },
              routesByName: parentContext.routesByName
            }) : undefined;
    } else {
      children$1 = undefined;
    }
    return {
            TAG: "Ok",
            _0: {
              TAG: "RouteEntry",
              _0: {
                loc: objLoc,
                name: RouteName.make(reverse(thisRouteNamePath), name.loc),
                path: {
                  loc: path.loc,
                  text: path.pathRaw
                },
                routePath: routePath,
                pathParams: pathParams,
                queryParams: path.queryParams.slice(),
                children: children$1,
                sourceFile: ctx.routeFileName,
                parentRouteFiles: toArray(parentContext.traversedRouteFiles),
                parentRouteLoc: parentContext.parentRouteLoc
              }
            }
          };
  }
  ctx.addDecodeError(objLoc, "This route entry is missing the \"name\" prop.");
  var routePath$1 = RoutePath.make(path.pathRaw, parentContext.currentRoutePath);
  return {
          TAG: "Ok",
          _0: {
            TAG: "RouteEntry",
            _0: {
              loc: objLoc,
              name: RouteName.make({
                    hd: "_",
                    tl: /* [] */0
                  }, dummyPos$1),
              path: {
                loc: path.loc,
                text: path.pathRaw
              },
              routePath: routePath$1,
              pathParams: pathParams,
              queryParams: path.queryParams.slice(),
              children: undefined,
              sourceFile: ctx.routeFileName,
              parentRouteFiles: toArray(parentContext.traversedRouteFiles),
              parentRouteLoc: parentContext.parentRouteLoc
            }
          }
        };
}

function decode(node, ctx, parentContext) {
  if (node !== undefined) {
    if (node.TAG === "Array") {
      var children = node.children;
      var loc = node.loc;
      if (children.length !== 0) {
        return decodeRouteChildren(children, ctx, {
                    seenQueryParams: parentContext.seenQueryParams,
                    currentRoutePath: parentContext.currentRoutePath,
                    currentRouteNamePath: parentContext.currentRouteNamePath,
                    seenPathParams: parentContext.seenPathParams,
                    traversedRouteFiles: parentContext.traversedRouteFiles,
                    parentRouteLoc: {
                      childrenArray: loc
                    },
                    routesByName: parentContext.routesByName
                  });
      } else {
        ctx.addDecodeError(loc, "Empty route file. Route files should not be empty.");
        return [];
      }
    }
    ctx.addDecodeError(node.loc, "Route files must have a top level array. Found " + nodeToString(node) + ".");
    return [];
  }
  ctx.addDecodeError({
        start: ctx.lineLookup.locationForIndex(0),
        end_: ctx.lineLookup.locationForIndex(0)
      }, "Empty file..");
  return [];
}

function parseRouteFile(routeFileName, config, decodeErrors, parserContext, parentContext) {
  var parseErrors = [];
  var content = parserContext.getRouteFileContents(routeFileName);
  if (content.TAG !== "Ok") {
    return {
            result: [],
            rawText: ""
          };
  }
  var content$1 = content._0;
  var lineLookup = new LinesAndColumns.LinesAndColumns(content$1);
  var ctx_addDecodeError = function (loc, message) {
    decodeErrors.push({
          routeFileName: routeFileName,
          message: message,
          loc: loc
        });
  };
  var ctx_getRouteFile = function (fileName, parentContext) {
    var match = parserContext.routeFileNames.includes(fileName);
    var match$1 = parserContext.routeFiles[fileName];
    if (match$1 !== undefined) {
      return {
              TAG: "Ok",
              _0: match$1
            };
    }
    if (match) {
      var match$2 = parseRouteFile(fileName, config, decodeErrors, parserContext, parentContext);
      var loadedRouteFile_rawText = match$2.rawText;
      var loadedRouteFile_content = match$2.result;
      var loadedRouteFile = {
        fileName: fileName,
        rawText: loadedRouteFile_rawText,
        content: loadedRouteFile_content
      };
      parserContext.routeFiles[fileName] = loadedRouteFile;
      return {
              TAG: "Ok",
              _0: loadedRouteFile
            };
    }
    var matched = FastFuzzy.search(fileName, parserContext.routeFileNames)[0];
    return {
            TAG: "Error",
            _0: "\"" + fileName + "\" could not be found. " + (
              matched !== undefined ? "Did you mean \"" + matched + "\"?" : "Does it exist?"
            )
          };
  };
  var ctx = {
    routeFileName: routeFileName,
    lineLookup: lineLookup,
    addDecodeError: ctx_addDecodeError,
    getRouteFile: ctx_getRouteFile
  };
  var nextParentContext_seenQueryParams = parentContext.seenQueryParams;
  var nextParentContext_currentRoutePath = parentContext.currentRoutePath;
  var nextParentContext_currentRouteNamePath = parentContext.currentRouteNamePath;
  var nextParentContext_seenPathParams = parentContext.seenPathParams;
  var nextParentContext_traversedRouteFiles = {
    hd: routeFileName,
    tl: parentContext.traversedRouteFiles
  };
  var nextParentContext_parentRouteLoc = parentContext.parentRouteLoc;
  var nextParentContext_routesByName = parentContext.routesByName;
  var nextParentContext = {
    seenQueryParams: nextParentContext_seenQueryParams,
    currentRoutePath: nextParentContext_currentRoutePath,
    currentRouteNamePath: nextParentContext_currentRouteNamePath,
    seenPathParams: nextParentContext_seenPathParams,
    traversedRouteFiles: nextParentContext_traversedRouteFiles,
    parentRouteLoc: nextParentContext_parentRouteLoc,
    routesByName: nextParentContext_routesByName
  };
  var node = JsoncParser$1.parseTree(content$1, parseErrors, {"disallowComments": false,"allowTrailingComma": true,"allowEmptyContent": true});
  var result = node !== undefined ? decode(transformNode(node, ctx), ctx, nextParentContext) : decode(undefined, ctx, nextParentContext);
  forEach(parseErrors[0], (function (parseError) {
          var linesAndColumns = new LinesAndColumns.LinesAndColumns(content$1);
          var match = getOr(decodeParseErrorCode(parseError.error), "InvalidSymbol");
          var tmp;
          switch (match) {
            case "InvalidSymbol" :
                tmp = "Invalid symbol.";
                break;
            case "InvalidNumberFormat" :
                tmp = "Invalid number format.";
                break;
            case "PropertyNameExpected" :
                tmp = "Expected property name.";
                break;
            case "ValueExpected" :
                tmp = "Expected value.";
                break;
            case "ColonExpected" :
                tmp = "Expected colon.";
                break;
            case "CommaExpected" :
                tmp = "Expected comma.";
                break;
            case "CloseBraceExpected" :
                tmp = "Expected close brace.";
                break;
            case "CloseBracketExpected" :
                tmp = "Expected close bracket.";
                break;
            case "EndOfFileExpected" :
                tmp = "Expected end of file.";
                break;
            case "InvalidCommentToken" :
                tmp = "Invalid comment token.";
                break;
            case "UnexpectedEndOfComment" :
                tmp = "Unexpected end of comment.";
                break;
            case "UnexpectedEndOfString" :
                tmp = "Unexpected end of string.";
                break;
            case "UnexpectedEndOfNumber" :
                tmp = "Unexpected end of number.";
                break;
            case "InvalidUnicode" :
                tmp = "Invalid unicode.";
                break;
            case "InvalidEscapeCharacter" :
                tmp = "Invalid escape character.";
                break;
            case "InvalidCharacter" :
                tmp = "Invalid character.";
                break;
            
          }
          decodeErrors.push({
                routeFileName: routeFileName,
                message: tmp,
                loc: {
                  start: linesAndColumns.locationForIndex(parseError.offset),
                  end_: linesAndColumns.locationForIndex(parseError.offset + parseError.length | 0)
                }
              });
        }));
  return {
          result: result,
          rawText: content$1
        };
}

function emptyParentCtx(routesByName) {
  return {
          seenQueryParams: [],
          currentRoutePath: RoutePath.empty(),
          currentRouteNamePath: /* [] */0,
          seenPathParams: /* [] */0,
          traversedRouteFiles: /* [] */0,
          parentRouteLoc: undefined,
          routesByName: routesByName
        };
}

function readRouteStructure$1(config, getRouteFileContents) {
  var routeFiles = {};
  var routesByName = {};
  var decodeErrors = [];
  var match = parseRouteFile("routes.json", config, decodeErrors, {
        routeFileNames: FastGlob.sync(["*.json"], {
              cwd: pathInRoutesFolder$1(config, undefined)
            }),
        routeFiles: routeFiles,
        getRouteFileContents: getRouteFileContents
      }, emptyParentCtx(routesByName));
  var result = match.result;
  routeFiles["routes.json"] = {
    fileName: "routes.json",
    rawText: match.rawText,
    content: result
  };
  return {
          errors: decodeErrors,
          result: result,
          routeFiles: routeFiles,
          routesByName: routesByName
        };
}
/* path Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


function make$5(str) {
  return $$Crypto.createHash("sha1").update(str).digest("base64");
}

function writeFileIfChanged(path, content) {
  if (Fs.existsSync(path)) {
    var existingFileContent = Fs.readFileSync(path, "utf-8");
    if (make$5(existingFileContent) !== make$5(content)) {
      Fs.writeFileSync(path, content);
      return ;
    } else {
      return ;
    }
  }
  Fs.writeFileSync(path, content);
}

var Fs$1 = {
  writeFileIfChanged: writeFileIfChanged
};

function onData(t, cb) {
  t.stdout.on("data", (function (buffer) {
          cb(buffer.toString());
        }));
}

var Spawn = {
  onData: onData
};

var ChildProcess = {
  Spawn: Spawn
};

var CosmiConfig = {
  make: (function (prim) {
      return Cosmiconfig.cosmiconfigSync("rescriptRelayRouter");
    })
};
/* fs Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


var Invalid_config = /* @__PURE__ */Caml_exceptions.create("RescriptRelayRouterCli__Utils.Invalid_config");

function resolveFullPath(path, filepath) {
  return Path.resolve(Path.dirname(filepath), path);
}

function load() {
  var match = CosmiConfig.make().search();
  var config;
  if (match == null) {
    throw {
          RE_EXN_ID: Invalid_config,
          _1: "Could not find router config. Please make sure you've defined a router config either in 'rescriptRelayRouter' in package.json, rescriptRelayRouter.json, or in rescriptRelayRouter.config.js/rescriptRelayRouter.config.cjs",
          Error: new Error()
        };
  }
  var config$1 = match.config;
  if (config$1 !== undefined) {
    var filepath = match.filepath;
    var routesFolderPath = config$1["routesFolderPath"];
    var routesFolderPath$1;
    if (routesFolderPath !== undefined) {
      routesFolderPath$1 = resolveFullPath(routesFolderPath, filepath);
    } else {
      throw {
            RE_EXN_ID: Invalid_config,
            _1: "You must set 'routesFolderPath', a relative path to where your routing code will be located.",
            Error: new Error()
          };
    }
    config = {
      generatedPath: resolveFullPath(getOr(config$1["generatedPath"], Path.join(routesFolderPath$1, "__generated__")), filepath),
      routesFolderPath: routesFolderPath$1,
      rescriptLibFolderPath: Path.join(Path.dirname(filepath), "lib", "bs")
    };
  } else {
    throw {
          RE_EXN_ID: Invalid_config,
          _1: "Could not find router config. Please make sure you've defined a router config either in 'rescriptRelayRouter' in package.json, rescriptRelayRouter.json, or in rescriptRelayRouter.config.js/rescriptRelayRouter.config.cjs",
          Error: new Error()
        };
  }
  if (!Fs.existsSync(config.generatedPath)) {
    console.log("Folder for generatedPath not found, creating...");
    Fs.mkdirSync(config.generatedPath, {"recursive":true});
  }
  if (!Fs.existsSync(config.routesFolderPath)) {
    console.log("Folder for routesFolderPath not found, creating...");
    Fs.mkdirSync(config.routesFolderPath, {"recursive":true});
  }
  return config;
}

function exists() {
  return isSome(Caml_option.nullable_to_opt(CosmiConfig.make().search()));
}

var Config = {
  load: load,
  exists: exists
};

function toTypeStr(queryParam) {
  if (typeof queryParam === "object") {
    if (queryParam.TAG === "Array") {
      return "array<" + toTypeStr(queryParam._0) + ">";
    } else {
      return queryParam.moduleName + ".t";
    }
  }
  switch (queryParam) {
    case "String" :
        return "string";
    case "Boolean" :
        return "bool";
    case "Int" :
        return "int";
    case "Float" :
        return "float";
    
  }
}

function toSerializer(queryParam, variableName) {
  if (typeof queryParam !== "object") {
    switch (queryParam) {
      case "String" :
          return variableName + "->encodeURIComponent";
      case "Boolean" :
          return "switch " + variableName + " { | true => \"true\" | false => \"false\" }";
      case "Int" :
          return "Int.toString(" + variableName + ")";
      case "Float" :
          return "Float.toString(" + variableName + ")";
      
    }
  } else {
    if (queryParam.TAG !== "Array") {
      return variableName + "->" + queryParam.moduleName + ".serialize->encodeURIComponent";
    }
    var inner = queryParam._0;
    if (typeof inner === "object") {
      if (inner.TAG === "Array") {
        return variableName;
      } else {
        return variableName + "->Array.map(value => value->" + inner.moduleName + ".serialize->encodeURIComponent)";
      }
    }
    switch (inner) {
      case "String" :
          return variableName + "->Array.map(encodeURIComponent)";
      case "Boolean" :
          return variableName + "->Array.map(bool => switch bool { | true => \"true\" | false => \"false\" })";
      case "Int" :
          return variableName + "->Array.map(Int.toString)";
      case "Float" :
          return variableName + "->Array.map(Float.toString)";
      
    }
  }
}

function toParser(queryParam, variableName) {
  if (typeof queryParam !== "object") {
    switch (queryParam) {
      case "String" :
          return "Some(" + variableName + "->decodeURIComponent)";
      case "Boolean" :
          return "switch " + variableName + " {\n      | \"true\" => Some(true)\n      | \"false\" => Some(false)\n      | _ => None\n      }";
      case "Int" :
          return "Int.fromString(" + variableName + ")";
      case "Float" :
          return "Float.fromString(" + variableName + ")";
      
    }
  } else {
    if (queryParam.TAG !== "Array") {
      return variableName + "->decodeURIComponent->" + queryParam.moduleName + ".parse";
    }
    var inner = queryParam._0;
    if (typeof inner === "object") {
      if (inner.TAG === "Array") {
        return variableName;
      } else {
        return variableName + "->Array.map(value => value->decodeURIComponent->" + inner.moduleName + ".parse)";
      }
    }
    switch (inner) {
      case "String" :
          return variableName + "->decodeURIComponent";
      case "Boolean" :
          return variableName + "->Array.map(value => switch value {\n      | \"true\" => Some(true)\n      | \"false\" => Some(false)\n      | _ => None\n      })";
      case "Int" :
          return variableName + "->Array.map(Int.fromString)";
      case "Float" :
          return variableName + "->Array.map(Float.fromString)";
      
    }
  }
}

var QueryParams = {
  toTypeStr: toTypeStr,
  toSerializer: toSerializer,
  toParser: toParser
};

function pathInRoutesFolder(config, fileNameOpt) {
  var fileName = fileNameOpt !== undefined ? fileNameOpt : "";
  return Path.join(config.routesFolderPath, fileName);
}

function pathInGeneratedFolder(config, fileNameOpt) {
  var fileName = fileNameOpt !== undefined ? fileNameOpt : "";
  return Path.join(config.generatedPath, fileName);
}

function fromRendererFileName(rendererName) {
  return rendererName.replace("_route_renderer.res", "");
}

function toRendererFileName(rendererName) {
  return rendererName + "_route_renderer.res";
}

function printablePathParamToTypeStr(p) {
  if (p.TAG === "PrintableRegularPathParam") {
    return getOr(p.pathToCustomModuleWithTypeT, "string");
  } else {
    return "[" + p.matchArms.map(function (b) {
                  return "#\"" + b + "\"";
                }).join(" | ") + "]";
  }
}

function printablePathParamToParamName(p) {
  return p.text;
}

function rawRouteToMatchable(route) {
  return {
          path: RoutePath.getPathSegment(route.path),
          params: route.params.map(printablePathParamToParamName),
          name: RouteName.getRouteName(route.name),
          fullName: RouteName.getFullRouteName(route.name),
          sourceFile: route.sourceFile,
          children: route.children.map(rawRouteToMatchable),
          queryParams: route.queryParams
        };
}

function matchRoutesCli(prim0, prim1) {
  return Caml_option.nullable_to_opt(matchRoutes(prim0, prim1));
}

function routeChildrenToPrintable(routeChildren) {
  var routes = [];
  routeChildren.forEach(function (child) {
        mapRouteChild(child, routes);
      });
  return routes;
}

function mapRouteChild(child, routes) {
  if (child.TAG === "Include") {
    child._0.content.forEach(function (child) {
          mapRouteChild(child, routes);
        });
    return ;
  }
  routes.push(parsedToPrintable(child._0));
}

function parsedToPrintable(routeEntry) {
  return {
          path: routeEntry.routePath,
          params: routeEntry.pathParams.map(function (p) {
                if (p.TAG === "PathParam") {
                  return {
                          TAG: "PrintableRegularPathParam",
                          text: p.text.text,
                          pathToCustomModuleWithTypeT: p.pathToCustomModuleWithTypeT
                        };
                } else {
                  return {
                          TAG: "PrintablePathParamWithMatchBranches",
                          text: p.text.text,
                          matchArms: p.matchArms
                        };
                }
              }),
          name: routeEntry.name,
          children: routeChildrenToPrintable(getOr(routeEntry.children, [])),
          queryParams: Object.fromEntries(routeEntry.queryParams.map(function (param) {
                    return [
                            param.name.text,
                            param.queryParam[1]
                          ];
                  })),
          sourceFile: routeEntry.sourceFile
        };
}

var Decode_error = /* @__PURE__ */Caml_exceptions.create("RescriptRelayRouterCli__Utils.Decode_error");

function readRouteStructure(config) {
  var routeStructure = readRouteStructure$1(config, (function (fileName) {
          try {
            return {
                    TAG: "Ok",
                    _0: Fs.readFileSync(pathInRoutesFolder(config, fileName), "utf-8")
                  };
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === Js_exn.$$Error) {
              return {
                      TAG: "Error",
                      _0: exn._1
                    };
            }
            throw exn;
          }
        }));
  if (routeStructure.errors.length > 0) {
    throw {
          RE_EXN_ID: Decode_error,
          _1: routeStructure,
          Error: new Error()
        };
  }
  var printable = routeChildrenToPrintable(routeStructure.result);
  var routeNames = {};
  var extractRoutes = function (routes) {
    routes.forEach(function (route) {
          routeNames[RouteName.getFullRouteName(route.name)] = [
            route,
            /* [] */0
          ];
          extractRoutes(route.children);
        });
  };
  extractRoutes(printable);
  return [
          printable,
          routeNames
        ];
}

function ensureRouteStructure(pathToRoutesFolder) {
  var routesFolderPath = Path.resolve(pathToRoutesFolder);
  var generatedPath = Path.join(routesFolderPath, "../__generated__");
  if (!Fs.existsSync(routesFolderPath)) {
    Fs.mkdirSync(routesFolderPath);
    console.log("[init] Routes folder did not exist. Created it at '" + routesFolderPath + "'.");
  }
  if (!Fs.existsSync(generatedPath)) {
    Fs.mkdirSync(generatedPath);
    return ;
  }
  
}

function printIndentation(str, indentation) {
  str.contents = str.contents + "  ".repeat(indentation);
}

function add(str, s) {
  str.contents = str.contents + s;
}

function printNestedRouteModules(route, indentation) {
  var moduleName = RouteName.getRouteName(route.name);
  var str = {
    contents: ""
  };
  var strEnd = {
    contents: ""
  };
  printIndentation(str, indentation);
  add(str, "/** [See route renderer](./" + RouteName.getRouteRendererFileName(route.name) + ")*/\n");
  printIndentation(str, indentation);
  add(str, "module " + moduleName + " = {\n");
  printIndentation(str, indentation + 1 | 0);
  add(str, "module Route = " + RouteName.toGeneratedRouteModuleName(route.name) + "\n");
  printIndentation(strEnd, indentation);
  add(strEnd, "}\n");
  route.children.forEach(function (route) {
        add(str, printNestedRouteModules(route, indentation + 1 | 0));
      });
  var contents = strEnd.contents.split("\n");
  return "\n" + str.contents + (contents.reverse(), contents.join("\n"));
}

function queryParamToQueryParamDecoder(param, key) {
  if (typeof param === "object") {
    if (param.TAG === "Array") {
      return "getArrayParamByKey(\"" + key + "\")->Option.map(value => value->Array.filterMap(value => " + toParser(param._0, "value") + ")),\n";
    }
    if (param.required) {
      return "getParamByKey(\"" + key + "\")->Option.flatMap(value => " + toParser(param, "value") + ")->Option.getOr(" + param.moduleName + ".defaultValue),\n";
    }
    
  }
  return "getParamByKey(\"" + key + "\")->Option.flatMap(value => " + toParser(param, "value") + "),\n";
}

function maybePluralize(text, count) {
  return text + (
          count === 1 ? "" : "s"
        );
}

function queryParamIsOptional(_qp) {
  while(true) {
    var qp = _qp;
    if (typeof qp !== "object") {
      return true;
    }
    if (qp.TAG !== "Array") {
      if (qp.required) {
        return false;
      } else {
        return true;
      }
    }
    _qp = qp._0;
    continue ;
  }}
/* fs Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


function $$delete$1(dict, string) {
  delete(dict[string]);
}
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function makeDiagnostic(range, message) {
  return {
          range: range,
          message: message,
          source: "RescriptRelayRouter"
        };
}

function makeHover(message, loc) {
  return {
          contents: {
            kind: "markdown",
            value: message
          },
          range: loc
        };
}

function makeCompletionItem(label, kind) {
  return {
          label: label,
          kind: kind
        };
}

function codeActionKindToString(kind) {
  switch (kind) {
    case "Empty" :
        return "";
    case "QuickFix" :
        return "quickfix";
    case "Refactor" :
        return "refactor";
    case "RefactorExtract" :
        return "refactor.extract";
    case "RefactorInline" :
        return "refactor.inline";
    case "RefactorRewrite" :
        return "refactor.rewrite";
    case "Source" :
        return "source";
    case "SourceOrganizeImports" :
        return "source.organizeImports";
    case "SourceFixAll" :
        return "source.fixAll";
    
  }
}

function make$4(uri, overwrite, ignoreIfExists) {
  return {
          kind: "create",
          uri: uri,
          options: {
            overwrite: overwrite,
            ignoreIfExists: ignoreIfExists
          }
        };
}

var CreateFile = {
  make: make$4
};

function make$1$1(textDocumentUri, edits) {
  return {
          textDocument: {
            uri: textDocumentUri
          },
          edits: edits
        };
}

var TextDocumentEdit = {
  make: make$1$1
};

var DocumentChange = {
  CreateFile: CreateFile,
  TextDocumentEdit: TextDocumentEdit
};

function makeOpenFileCommand(title, fileUri) {
  return {
          title: title,
          command: "vscode.open",
          arguments: [fileUri]
        };
}

function makeOpenFileAtPosCommand(title, fileUri, pos) {
  return {
          title: title,
          command: "vscode-rescript-relay.open-pos-in-doc",
          arguments: [
            fileUri,
            pos.line.toString(),
            pos.character.toString()
          ]
        };
}

function makeOpenRouteDefinitionsCommand(title, routes) {
  return {
          title: title,
          command: "vscode-rescript-relay.open-route-definitions",
          arguments: routes.map(function (r) {
                return r.sourceFilePath + ";" + r.routeName + ";" + r.loc.line.toString() + ";" + r.loc.character.toString() + ";" + r.routeRendererFilePath;
              })
        };
}

function makeTextOnlyCommand(title) {
  return {
          title: title,
          command: "",
          arguments: undefined
        };
}

var Command = {
  makeOpenFileCommand: makeOpenFileCommand,
  makeOpenFileAtPosCommand: makeOpenFileAtPosCommand,
  makeOpenRouteDefinitionsCommand: makeOpenRouteDefinitionsCommand,
  makeTextOnlyCommand: makeTextOnlyCommand
};

function makeCodeLensItem(range, command) {
  return {
          range: range,
          command: command
        };
}

function makeDocumentLink(range, fileUri, tooltip) {
  return {
          range: range,
          target: fileUri,
          tooltip: tooltip
        };
}
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function findRouteWithName(routeName, routeChildren) {
  var res = {
    contents: undefined
  };
  var searchForRouteWithName = function (routeName, routeChildren) {
    routeChildren.forEach(function (routeEntry) {
          if (routeEntry.TAG === "Include") {
            return searchForRouteWithName(routeName, routeEntry._0.content);
          }
          var routeEntry$1 = routeEntry._0;
          var children = routeEntry$1.children;
          if (RouteName.getFullRouteName(routeEntry$1.name) === routeName) {
            res.contents = routeEntry$1;
            return ;
          } else if (children !== undefined) {
            return searchForRouteWithName(routeName, children);
          } else {
            return ;
          }
        });
  };
  searchForRouteWithName(routeName, routeChildren);
  return res.contents;
}

function routeNameFromRouteRendererFileName(routeRendererFileName) {
  return routeRendererFileName.split("_route_renderer.res")[0];
}
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function mapRange(range) {
  return {
          start: {
            line: range.start.line,
            character: range.start.column
          },
          end: {
            line: range.end_.line,
            character: range.end_.column
          }
        };
}

function mapPos(loc) {
  return {
          line: loc.line,
          character: loc.column
        };
}

function mapRangeFromStartOnly(range) {
  return {
          start: {
            line: range.start.line,
            character: range.start.column
          },
          end: {
            line: range.start.line,
            character: range.start.column
          }
        };
}

function hasPos(range, pos) {
  var pos_0 = pos.line;
  var pos_1 = pos.character;
  var pos$1 = [
    pos_0,
    pos_1
  ];
  var posStart_0 = range.start.line;
  var posStart_1 = range.start.character;
  var posStart = [
    posStart_0,
    posStart_1
  ];
  var posEnd_0 = range.end.line;
  var posEnd_1 = range.end.character;
  var posEnd = [
    posEnd_0,
    posEnd_1
  ];
  if (Caml_obj.lessequal(posStart, pos$1)) {
    return Caml_obj.lessequal(pos$1, posEnd);
  } else {
    return false;
  }
}

function findPosInRouteChildren(children, ctx) {
  var pos = ctx.pos;
  var children$1 = children.slice();
  var $$break = {
    contents: false
  };
  var foundContext = {
    contents: undefined
  };
  var setFoundContext = function (ctx) {
    foundContext.contents = ctx;
    $$break.contents = true;
  };
  while($$break.contents === false) {
    var match = children$1.shift();
    if (match !== undefined) {
      if (match.TAG === "Include") {
        var includeEntry = match._0;
        var fileName = includeEntry.fileName;
        var keyLoc = includeEntry.keyLoc;
        if (hasPos(mapRange(includeEntry.loc), pos)) {
          var match$1 = hasPos(mapRange(fileName.loc), pos);
          var match$2 = hasPos(mapRange(keyLoc), pos);
          if (match$1) {
            setFoundContext({
                  TAG: "IncludeEntry",
                  includeEntry: includeEntry,
                  innerLocation: {
                    TAG: "FileName",
                    _0: fileName
                  }
                });
          } else if (match$2) {
            setFoundContext({
                  TAG: "IncludeEntry",
                  includeEntry: includeEntry,
                  innerLocation: {
                    TAG: "Key",
                    _0: keyLoc
                  }
                });
          } else {
            var astLocation = findPosInRouteChildren(includeEntry.content, ctx);
            if (astLocation !== undefined) {
              setFoundContext(astLocation);
            } else {
              setFoundContext({
                    TAG: "IncludeEntry",
                    includeEntry: includeEntry,
                    innerLocation: undefined
                  });
            }
          }
        }
        
      } else {
        var routeEntry = match._0;
        var path = routeEntry.path;
        var name = routeEntry.name;
        if (hasPos(mapRange(routeEntry.loc), pos)) {
          var match$3 = hasPos(mapRange(RouteName.getLoc(name)), pos);
          var match$4 = hasPos(mapRange(path.loc), pos);
          if (match$3) {
            setFoundContext({
                  TAG: "RouteEntry",
                  routeEntry: routeEntry,
                  innerLocation: {
                    TAG: "Name",
                    _0: {
                      TAG: "NameText",
                      _0: {
                        loc: RouteName.getLoc(name),
                        text: RouteName.getRouteName(name)
                      }
                    }
                  }
                });
          } else if (match$4) {
            setFoundContext({
                  TAG: "RouteEntry",
                  routeEntry: routeEntry,
                  innerLocation: {
                    TAG: "Path",
                    _0: {
                      TAG: "FullPath",
                      path: path
                    }
                  }
                });
          } else {
            var astLocation$1 = findPosInRouteChildren(getOr(routeEntry.children, []), ctx);
            if (astLocation$1 !== undefined) {
              setFoundContext(astLocation$1);
            } else {
              setFoundContext({
                    TAG: "RouteEntry",
                    routeEntry: routeEntry,
                    innerLocation: undefined
                  });
            }
          }
        }
        
      }
    } else {
      $$break.contents = true;
    }
  }  return foundContext.contents;
}

function findRequestContext(routeStructure, ctx) {
  var routeFileName = Path.basename(ctx.fileUri);
  var match = routeStructure.routeFiles[routeFileName];
  if (match !== undefined) {
    return findPosInRouteChildren(match.content, ctx);
  }
  
}

function hover(routeStructure, ctx) {
  var astLocation = findRequestContext(routeStructure, ctx);
  if (astLocation === undefined) {
    return ;
  }
  if (astLocation.TAG === "IncludeEntry") {
    var innerLocation = astLocation.innerLocation;
    if (innerLocation === undefined) {
      return ;
    }
    if (innerLocation.TAG !== "FileName") {
      return makeHover("Defines an include attribute.", mapRange(innerLocation._0));
    }
    var fileName = innerLocation._0;
    return makeHover("Filename: \"" + fileName.text + "\"", mapRange(fileName.loc));
  }
  var routeEntry = astLocation.routeEntry;
  var routeName = RouteName.getFullRouteName(routeEntry.name);
  return makeHover("\n**Full route name**\n\n\`" + routeName + "\`\n\n\n\n**Full route path**\n\n\`" + RoutePath.getFullRoutePath(routeEntry.routePath) + "\`\n", mapRange(routeEntry.loc));
}

function resolveRouteFileCompletions(matchText, includeEntry, ctx) {
  var currentFileName = Path.basename(ctx.fileUri);
  var potentialMatches = ctx.routeFileNames.filter(function (routeFileName) {
        if (routeFileName !== currentFileName) {
          return !includeEntry.parentRouteFiles.includes(routeFileName);
        } else {
          return false;
        }
      });
  if (matchText === "") {
    return potentialMatches.map(function (matchedLabel) {
                return makeCompletionItem(matchedLabel, "Class");
              });
  } else {
    return FastFuzzy.search(matchText, potentialMatches).map(function (matchedLabel) {
                return makeCompletionItem(matchedLabel, "Class");
              });
  }
}

function completion(routeStructure, ctx) {
  var astLocation = findRequestContext(routeStructure, ctx);
  if (astLocation === undefined) {
    return ;
  }
  var emptyCompletionList = [];
  if (astLocation.TAG === "IncludeEntry") {
    var innerLocation = astLocation.innerLocation;
    if (innerLocation !== undefined) {
      if (innerLocation.TAG === "FileName") {
        return resolveRouteFileCompletions(innerLocation._0.text, astLocation.includeEntry, ctx);
      } else {
        return emptyCompletionList;
      }
    } else {
      return ;
    }
  }
  var innerLocation$1 = astLocation.innerLocation;
  if (innerLocation$1 === undefined) {
    return ;
  }
  switch (innerLocation$1.TAG) {
    case "Key" :
    case "Path" :
        return emptyCompletionList;
    case "Name" :
        return ;
    
  }
}

function codeActions(routeStructure, ctx) {
  var astLocation = findRequestContext(routeStructure, ctx);
  if (astLocation === undefined) {
    return ;
  }
  if (astLocation.TAG === "IncludeEntry") {
    return ;
  }
  var match = astLocation.routeEntry.parentRouteLoc;
  if (match === undefined) {
    return ;
  }
  var childrenArray = match.childrenArray;
  return [{
            title: "Add route entry",
            kind: codeActionKindToString("Refactor"),
            isPreferred: undefined,
            edit: {
              documentChanges: [DocumentChange.TextDocumentEdit.make(ctx.fileUri, [{
                        range: {
                          start: mapPos(childrenArray.end_),
                          end: mapPos(childrenArray.end_)
                        },
                        newText: "{}"
                      }])]
            }
          }];
}

function codeLens(routeStructure, ctx) {
  var lenses = [];
  var addLens = function (range, command) {
    lenses.push(makeCodeLensItem(range, command));
  };
  var traverseRouteChildren = function (routeChildren, ctx) {
    routeChildren.forEach(function (child) {
          if (child.TAG === "Include") {
            return ;
          }
          var routeEntry = child._0;
          var fullRouteName = RouteName.getFullRouteName(routeEntry.name);
          addLens(mapRangeFromStartOnly(RouteName.getLoc(routeEntry.name)), Command.makeTextOnlyCommand(fullRouteName));
          addLens(mapRangeFromStartOnly(routeEntry.path.loc), Command.makeTextOnlyCommand(RoutePath.getFullRoutePath(routeEntry.routePath)));
          traverseRouteChildren(getOr(routeEntry.children, []));
        });
  };
  var routeFileName = Path.basename(ctx.fileUri);
  var match = routeStructure.routeFiles[routeFileName];
  if (match !== undefined) {
    traverseRouteChildren(match.content);
  }
  var match$1 = lenses.length;
  if (match$1 !== 0) {
    return lenses;
  }
  
}

function routeRendererCodeLens(routeStructure, routeRendererFileName, routeRendererFileContent, ctx) {
  var lines = routeRendererFileContent.split("\n");
  var foundRenderer;
  for(var lineIdx = 0 ,lineIdx_finish = lines.length; lineIdx < lineIdx_finish; ++lineIdx){
    var match = foundRenderer;
    if (match === undefined) {
      var line = lines[lineIdx];
      if (line.includes("makeRenderer(")) {
        var characterStart = line.indexOf("makeRenderer(");
        var characterEnd = line.length;
        var range_start = {
          line: lineIdx,
          character: characterStart
        };
        var range_end = {
          line: lineIdx,
          character: characterEnd
        };
        var range = {
          start: range_start,
          end: range_end
        };
        var routeName = routeNameFromRouteRendererFileName(routeRendererFileName);
        var routeEntry = flatMap(routeName, (function (routeName) {
                return findRouteWithName(routeName, routeStructure.result);
              }));
        if (routeEntry !== undefined) {
          foundRenderer = makeCodeLensItem(range, Command.makeOpenFileAtPosCommand("Open route definition", pathInRoutesFolder(ctx.config, routeEntry.sourceFile), mapPos(routeEntry.loc.start)));
        }
        
      }
      
    }
    
  }
  var rendererCodeLens = foundRenderer;
  if (rendererCodeLens !== undefined) {
    return [rendererCodeLens];
  }
  
}

function documentLinks(routeStructure, ctx) {
  var documentLinks$1 = [];
  var addDocumentLink = function (range, fileUri, tooltip) {
    documentLinks$1.push(makeDocumentLink(range, fileUri, tooltip));
  };
  var traverseRouteChildren = function (routeChildren, ctx) {
    routeChildren.forEach(function (child) {
          if (child.TAG === "Include") {
            var includeEntry = child._0;
            if (ctx.routeFileNames.includes(includeEntry.fileName.text)) {
              return addDocumentLink(mapRange(includeEntry.fileName.loc), pathInRoutesFolder(ctx.config, includeEntry.fileName.text), "Open file");
            } else {
              return ;
            }
          }
          var routeEntry = child._0;
          addDocumentLink(mapRange(RouteName.getLoc(routeEntry.name)), pathInRoutesFolder(ctx.config, RouteName.getRouteRendererFileName(routeEntry.name)), "Open route renderer");
          traverseRouteChildren(getOr(routeEntry.children, []), ctx);
        });
  };
  var routeFileName = Path.basename(ctx.fileUri);
  var match = routeStructure.routeFiles[routeFileName];
  if (match !== undefined) {
    traverseRouteChildren(match.content, ctx);
  }
  var match$1 = documentLinks$1.length;
  if (match$1 !== 0) {
    return documentLinks$1;
  }
  
}

function diagnostics(errors) {
  var diagnosticsPerFile = {};
  errors.forEach(function (error) {
        var diagnosticsArray = diagnosticsPerFile[error.routeFileName];
        var targetDiagnosticsArray;
        if (diagnosticsArray !== undefined) {
          targetDiagnosticsArray = diagnosticsArray;
        } else {
          var diagnosticsArray$1 = [];
          diagnosticsPerFile[error.routeFileName] = diagnosticsArray$1;
          targetDiagnosticsArray = diagnosticsArray$1;
        }
        targetDiagnosticsArray.push(makeDiagnostic(mapRange(error.loc), error.message));
      });
  return Object.entries(diagnosticsPerFile);
}
/* path Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


function fromString(i) {
  var i$1 = parseFloat(i);
  if (isNaN(i$1)) {
    return ;
  } else {
    return i$1;
  }
}
/* No side effect */

// Generated by ReScript, PLEASE EDIT WITH CARE


function getLastBuiltFromCompilerLog(config) {
  var compilerLogConents = Fs.readFileSync(Path.resolve(config.rescriptLibFolderPath, ".compiler.log"), "utf-8").split(Os.EOL);
  var statusLine = getOr(compilerLogConents[compilerLogConents.length - 2 | 0], "");
  if (statusLine.startsWith("#Done(")) {
    return fromString(statusLine.split("#Done(")[1].split(")")[0]);
  }
  
}

function readDeps(config) {
  return new Promise((function (resolve, param) {
                var byModuleNames = {};
                var t = Child_process.spawn("find", [
                      ".",
                      "-name",
                      "\"*.d\"",
                      "-type",
                      "f",
                      "|",
                      "xargs",
                      "cat"
                    ], {
                      shell: true,
                      cwd: config.rescriptLibFolderPath
                    });
                ChildProcess.Spawn.onData(t, (function (lines) {
                        lines.split(Os.EOL).forEach(function (line) {
                              var lineContents = line.split(" : ");
                              if (lineContents.length !== 2) {
                                return ;
                              }
                              var filenameRaw = lineContents[0];
                              var depsLine = lineContents[1];
                              var currentTargetModule = Path.parse(filenameRaw.trim()).name;
                              var dependsOnTheseModules = reduce(depsLine.split(" ").map(function (s) {
                                        return Path.parse(s.trim()).name;
                                      }), [], (function (acc, curr) {
                                      if (!(acc.includes(curr) && curr !== currentTargetModule)) {
                                        acc.push(curr);
                                      }
                                      return acc;
                                    }));
                              var existingEntry = byModuleNames[currentTargetModule];
                              if (existingEntry !== undefined) {
                                dependsOnTheseModules.forEach(function (m) {
                                      existingEntry.dependsOn.add(m);
                                    });
                              } else {
                                var entry_dependsOn = new Set(dependsOnTheseModules);
                                var entry_dependents = new Set();
                                var entry = {
                                  dependsOn: entry_dependsOn,
                                  dependents: entry_dependents
                                };
                                byModuleNames[currentTargetModule] = entry;
                              }
                              dependsOnTheseModules.forEach(function (m) {
                                    var existingEntry = byModuleNames[m];
                                    if (existingEntry !== undefined) {
                                      existingEntry.dependents.add(currentTargetModule);
                                    } else {
                                      byModuleNames[m] = {
                                        dependsOn: new Set(),
                                        dependents: new Set([currentTargetModule])
                                      };
                                    }
                                  });
                            });
                      }));
                t.on("close", (function (exitCode) {
                        resolve(exitCode === 0 ? ({
                                  TAG: "Ok",
                                  _0: byModuleNames
                                }) : ({
                                  TAG: "Error",
                                  _0: "Failed with exit code: " + exitCode.toString()
                                }));
                      }));
              }));
}
/* fs Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


var initialized = {
  contents: false
};

var shutdownRequestAlreadyReceived = {
  contents: false
};

var dummyPos = {
  line: -1,
  character: -1
};

var jsonrpcVersion = "2.0";

function decodeLspMessage(msg) {
  var match = msg.method;
  if (match === "textDocument/rescriptRelayRouterRoutesMatchingUrl") {
    return {
            TAG: "RescriptRelayRouterRoutesMatchingUrl",
            _0: msg.params
          };
  } else if (match === "textDocument/rescriptRelayRouterRoutes") {
    return {
            TAG: "RescriptRelayRouterRoutes",
            _0: msg.params
          };
  } else if (match === "textDocument/completion") {
    return {
            TAG: "Completion",
            _0: msg.params
          };
  } else if (match === "textDocument/didClose") {
    return {
            TAG: "DidCloseTextDocumentNotification",
            _0: msg.params
          };
  } else if (match === "textDocument/documentLink") {
    return {
            TAG: "DocumentLinks",
            _0: msg.params
          };
  } else if (match === "textDocument/didChange") {
    return {
            TAG: "DidChangeTextDocumentNotification",
            _0: msg.params
          };
  } else if (match === "textDocument/didOpen") {
    return {
            TAG: "DidOpenTextDocumentNotification",
            _0: msg.params
          };
  } else if (match === "textDocument/hover") {
    return {
            TAG: "Hover",
            _0: msg.params
          };
  } else if (match === "textDocument/codeLens") {
    return {
            TAG: "CodeLens",
            _0: msg.params
          };
  } else if (match === "textDocument/codeAction") {
    return {
            TAG: "CodeAction",
            _0: msg.params
          };
  } else {
    return "UnmappedMessage";
  }
}

function asMessage(notification) {
  return {
          jsonrpc: jsonrpcVersion,
          method: "textDocument/publishDiagnostics",
          params: notification._0
        };
}

function codeToInt(code) {
  if (code === "ServerNotInitialized") {
    return -32002;
  } else {
    return -32600;
  }
}

function make(code, message) {
  return {
          code: codeToInt(code),
          message: message
        };
}

function make$1(textDocumentSyncOpt, hoverProviderOpt, completionProvider, codeLensProviderOpt, documentLinkProviderOpt, codeActionProviderOpt) {
  var hoverProvider = hoverProviderOpt !== undefined ? hoverProviderOpt : false;
  var codeLensProvider = codeLensProviderOpt !== undefined ? codeLensProviderOpt : false;
  var documentLinkProvider = documentLinkProviderOpt !== undefined ? documentLinkProviderOpt : false;
  var codeActionProvider = codeActionProviderOpt !== undefined ? codeActionProviderOpt : false;
  return {
          capabilities: {
            textDocumentSync: 1,
            hoverProvider: hoverProvider,
            completionProvider: completionProvider,
            codeLensProvider: codeLensProvider,
            documentLinkProvider: documentLinkProvider,
            codeActionProvider: codeActionProvider
          }
        };
}

function make$2(id, error, result) {
  return {
          jsonrpc: jsonrpcVersion,
          id: id,
          error: error,
          result: result
        };
}

function defaultSendFn(param) {
  
}

var sendFn = {
  contents: defaultSendFn
};

function make$3(config, getRouteFileContents, routeRenderersCache) {
  return {
          routeStructure: readRouteStructure$1(config, getRouteFileContents),
          config: config,
          routeFileNames: FastGlob.sync(["*.json"], {
                cwd: pathInRoutesFolder(config, undefined)
              }),
          routeRenderersCache: routeRenderersCache
        };
}

function isValidRouteFile(t, maybeFileUri) {
  var fileUri = maybeFileUri.startsWith("file://") ? Url.fileURLToPath(maybeFileUri) : maybeFileUri;
  var fileName = Path.basename(fileUri);
  return fileUri === pathInRoutesFolder(t.config, fileName);
}

function start(mode, config) {
  var routeFilesCaches = {};
  var routeRenderersCache = {};
  var moduleDepsCache = {
    cache: {},
    compilerLastRebuilt: 0
  };
  var getRouteFileContents = function (fileName) {
    var contents = routeFilesCaches[fileName];
    if (contents !== undefined) {
      return {
              TAG: "Ok",
              _0: contents
            };
    }
    try {
      return {
              TAG: "Ok",
              _0: Fs.readFileSync(pathInRoutesFolder(config, fileName), "utf-8")
            };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Js_exn.$$Error) {
        return {
                TAG: "Error",
                _0: exn._1
              };
      }
      throw exn;
    }
  };
  var filesWithDiagnostics = {
    contents: []
  };
  var buildCurrentLspResolveContext = function () {
    return make$3(config, getRouteFileContents, routeRenderersCache);
  };
  var currentLspResolveContext = {
    contents: buildCurrentLspResolveContext()
  };
  var rebuildLspResolveContext = function () {
    var lspResolveContext = buildCurrentLspResolveContext();
    currentLspResolveContext.contents = lspResolveContext;
    var filesWithDiagnosticsAtLastPublish = filesWithDiagnostics.contents.slice();
    var currentFilesWithDiagnostics = [];
    diagnostics(lspResolveContext.routeStructure.errors).forEach(function (param) {
          var fileName = param[0];
          currentFilesWithDiagnostics.push(fileName);
          var msg = asMessage({
                TAG: "PublishDiagnostics",
                _0: {
                  uri: pathInRoutesFolder(lspResolveContext.config, fileName),
                  diagnostics: param[1]
                }
              });
          sendFn.contents(msg);
        });
    filesWithDiagnostics.contents = currentFilesWithDiagnostics;
    filesWithDiagnosticsAtLastPublish.forEach(function (fileName) {
          if (currentFilesWithDiagnostics.includes(fileName)) {
            return ;
          }
          var msg = asMessage({
                TAG: "PublishDiagnostics",
                _0: {
                  uri: pathInRoutesFolder(lspResolveContext.config, fileName),
                  diagnostics: []
                }
              });
          sendFn.contents(msg);
        });
  };
  var rebuildingDepsCachePromise = {
    contents: undefined
  };
  var doRebuildDepsCacheIfNeeded = async function () {
    var config = currentLspResolveContext.contents.config;
    var currentLastBuiltAt = moduleDepsCache.compilerLastRebuilt;
    var lastBuiltAt = getOr(getLastBuiltFromCompilerLog(config), 0);
    if (lastBuiltAt <= currentLastBuiltAt) {
      return {
              TAG: "Ok",
              _0: moduleDepsCache
            };
    }
    var depsByModuleNames = await readDeps(config);
    if (depsByModuleNames.TAG !== "Ok") {
      return {
              TAG: "Error",
              _0: depsByModuleNames._0
            };
    }
    moduleDepsCache.cache = depsByModuleNames._0;
    moduleDepsCache.compilerLastRebuilt = lastBuiltAt;
    return {
            TAG: "Ok",
            _0: moduleDepsCache
          };
  };
  var getFreshModuleDepsCache = function () {
    var match = rebuildingDepsCachePromise.contents;
    if (match !== undefined) ; else {
      rebuildingDepsCachePromise.contents = Caml_option.some(doRebuildDepsCacheIfNeeded().then(function (res) {
                rebuildingDepsCachePromise.contents = undefined;
                return res;
              }));
    }
    return rebuildingDepsCachePromise.contents;
  };
  var findRoutesForFile = function (moduleName, moduleDepsCache, foundRoutes) {
    var match = moduleDepsCache.cache[moduleName];
    if (match !== undefined) {
      match.dependents.forEach(function (mName) {
            if (mName.endsWith("_route_renderer")) {
              foundRoutes.add(mName.slice(0, Math.imul("_route_renderer".length, -1)));
              return ;
            } else {
              return findRoutesForFile(mName, moduleDepsCache, foundRoutes);
            }
          });
      return ;
    }
    
  };
  var openedFile = function (uri, text) {
    var key = Path.basename(uri);
    var match = Path.extname(uri);
    switch (match) {
      case ".json" :
          routeFilesCaches[key] = text;
          return rebuildLspResolveContext();
      case ".res" :
          routeRenderersCache[key] = text;
          return ;
      default:
        return ;
    }
  };
  var updateOpenedFile = function (uri, text) {
    var key = Path.basename(uri);
    var targetCache = Path.extname(uri) === ".res" ? routeRenderersCache : routeFilesCaches;
    if (isSome(targetCache[key])) {
      targetCache[key] = text;
      return rebuildLspResolveContext();
    }
    
  };
  var closeFile = function (uri) {
    var key = Path.basename(uri);
    $$delete$1(routeFilesCaches, key);
    $$delete$1(routeRenderersCache, key);
    rebuildLspResolveContext();
  };
  var routeFilesWatcher = Chokidar.watch(pathInRoutesFolder(config, "*.json")).on("change", (function (param) {
            rebuildLspResolveContext();
          })).on("unlink", (function (param) {
          rebuildLspResolveContext();
        }));
  var onMessage = function (msg) {
    var ctx = currentLspResolveContext.contents;
    if (MessagesJs.isNotificationMessage(msg)) {
      var match = initialized.contents;
      var match$1 = msg.method;
      if (match) {
        if (match$1 === "exit") {
          if (shutdownRequestAlreadyReceived.contents === true) {
            process.exit(0);
          } else {
            process.exit(1);
          }
        } else {
          var params = decodeLspMessage(msg);
          if (typeof params === "object") {
            switch (params.TAG) {
              case "DidOpenTextDocumentNotification" :
                  var params$1 = params._0;
                  if (isValidRouteFile(ctx, params$1.textDocument.uri)) {
                    openedFile(params$1.textDocument.uri, params$1.textDocument.text);
                  }
                  break;
              case "DidChangeTextDocumentNotification" :
                  var params$2 = params._0;
                  var match$2 = isValidRouteFile(ctx, params$2.textDocument.uri);
                  var match$3 = params$2.contentChanges.slice().pop();
                  if (match$2 && match$3 !== undefined) {
                    updateOpenedFile(params$2.textDocument.uri, match$3.text);
                  }
                  break;
              case "DidCloseTextDocumentNotification" :
                  closeFile(params._0.textDocument.uri);
                  break;
                
            }
          }
          
        }
        return ;
      }
      console.error("Could not handle notification message.");
      return ;
    }
    if (!MessagesJs.isRequestMessage(msg)) {
      return ;
    }
    var match$4 = initialized.contents;
    var match$5 = msg.method;
    if (match$4) {
      if (match$5 === "shutdown") {
        if (shutdownRequestAlreadyReceived.contents === true) {
          var msg$1 = make$2(msg.id, Caml_option.some(make("InvalidRequest", "Language server already received the shutdown request.")), undefined);
          return sendFn.contents(msg$1);
        }
        shutdownRequestAlreadyReceived.contents = true;
        routeFilesWatcher.close();
        var msg$2 = make$2(msg.id, undefined, null);
        return sendFn.contents(msg$2);
      }
      if (match$5 === "initialize") {
        var msg$3 = make$2(msg.id, undefined, null);
        return sendFn.contents(msg$3);
      }
      var ctx$1 = currentLspResolveContext.contents;
      var params$3 = decodeLspMessage(msg);
      if (typeof params$3 === "object") {
        switch (params$3.TAG) {
          case "Hover" :
              var params$4 = params$3._0;
              if (Path.extname(params$4.textDocument.uri) !== ".json") {
                return ;
              }
              var hover$1 = hover(ctx$1.routeStructure, {
                    fileUri: Path.basename(params$4.textDocument.uri),
                    pos: params$4.position,
                    config: ctx$1.config,
                    routeFileNames: ctx$1.routeFileNames
                  });
              var result = hover$1 !== undefined ? hover$1 : null;
              var msg$4 = make$2(msg.id, undefined, Caml_option.some(result));
              return sendFn.contents(msg$4);
          case "CodeLens" :
              var params$5 = params$3._0;
              var match$6 = Path.extname(params$5.textDocument.uri);
              switch (match$6) {
                case ".json" :
                    var codeLenses = codeLens(ctx$1.routeStructure, {
                          fileUri: Path.basename(params$5.textDocument.uri),
                          pos: dummyPos,
                          config: ctx$1.config,
                          routeFileNames: ctx$1.routeFileNames
                        });
                    var result$1 = codeLenses !== undefined ? codeLenses : null;
                    var msg$5 = make$2(msg.id, undefined, Caml_option.some(result$1));
                    return sendFn.contents(msg$5);
                case ".res" :
                    var fileName = Path.basename(params$5.textDocument.uri);
                    if (fileName.endsWith("route_renderer.res")) {
                      var routeRendererContent = ctx$1.routeRenderersCache[fileName];
                      var result$2;
                      if (routeRendererContent !== undefined) {
                        var codeLenses$1 = routeRendererCodeLens(ctx$1.routeStructure, fileName, routeRendererContent, {
                              fileUri: fileName,
                              pos: dummyPos,
                              config: ctx$1.config,
                              routeFileNames: ctx$1.routeFileNames
                            });
                        result$2 = codeLenses$1 !== undefined ? codeLenses$1 : null;
                      } else {
                        result$2 = null;
                      }
                      var msg$6 = make$2(msg.id, undefined, Caml_option.some(result$2));
                      return sendFn.contents(msg$6);
                    }
                    var promise = getFreshModuleDepsCache();
                    if (promise !== undefined) {
                      Caml_option.valFromOption(promise).then(function (res) {
                            if (res.TAG !== "Ok") {
                              return ;
                            }
                            var thisModuleName = Path.parse(fileName).name;
                            var foundRoutes = new Set();
                            findRoutesForFile(thisModuleName, res._0, foundRoutes);
                            if (foundRoutes.size <= 0) {
                              return ;
                            }
                            var result = [
                              makeCodeLensItem({
                                    start: {
                                      line: 0,
                                      character: 0
                                    },
                                    end: {
                                      line: 0,
                                      character: 0
                                    }
                                  }, Command.makeTextOnlyCommand("RescriptRelayRouter: Referenced in " + foundRoutes.size.toString() + " " + maybePluralize("route", foundRoutes.size))),
                              makeCodeLensItem({
                                    start: {
                                      line: 0,
                                      character: 0
                                    },
                                    end: {
                                      line: 0,
                                      character: 0
                                    }
                                  }, Command.makeOpenRouteDefinitionsCommand("Open definition for " + (
                                        foundRoutes.size > 1 ? "routes" : "route " + Array.from(foundRoutes.values())[0]
                                      ), filterMap$1(Array.from(foundRoutes.values()), (function (routeName) {
                                              var routeEntry = findRouteWithName(routeName, ctx$1.routeStructure.result);
                                              if (routeEntry !== undefined) {
                                                return {
                                                        sourceFilePath: pathInRoutesFolder(ctx$1.config, routeEntry.sourceFile),
                                                        routeName: routeName,
                                                        loc: {
                                                          line: routeEntry.loc.start.line,
                                                          character: routeEntry.loc.start.column
                                                        },
                                                        routeRendererFilePath: pathInRoutesFolder(ctx$1.config, RouteName.getRouteRendererName(routeEntry.name))
                                                      };
                                              }
                                              
                                            }))))
                            ];
                            var msg$7 = make$2(msg.id, undefined, Caml_option.some(result));
                            sendFn.contents(msg$7);
                          });
                      return ;
                    } else {
                      return ;
                    }
                default:
                  return ;
              }
          case "DocumentLinks" :
              var params$6 = params$3._0;
              if (Path.extname(params$6.textDocument.uri) !== ".json") {
                return ;
              }
              var documentLinks$1 = documentLinks(ctx$1.routeStructure, {
                    fileUri: Path.basename(params$6.textDocument.uri),
                    pos: dummyPos,
                    config: ctx$1.config,
                    routeFileNames: ctx$1.routeFileNames
                  });
              var result$3 = documentLinks$1 !== undefined ? documentLinks$1 : null;
              var msg$7 = make$2(msg.id, undefined, Caml_option.some(result$3));
              return sendFn.contents(msg$7);
          case "Completion" :
              var params$7 = params$3._0;
              if (Path.extname(params$7.textDocument.uri) === ".json") {
                var completionItems = completion(ctx$1.routeStructure, {
                      fileUri: Path.basename(params$7.textDocument.uri),
                      pos: params$7.position,
                      config: ctx$1.config,
                      routeFileNames: ctx$1.routeFileNames
                    });
                var result$4 = completionItems !== undefined ? completionItems : null;
                var msg$8 = make$2(msg.id, undefined, Caml_option.some(result$4));
                return sendFn.contents(msg$8);
              }
              var msg$9 = make$2(msg.id, undefined, null);
              return sendFn.contents(msg$9);
          case "CodeAction" :
              var params$8 = params$3._0;
              if (Path.extname(params$8.textDocument.uri) === ".json") {
                var codeActions$1 = codeActions(ctx$1.routeStructure, {
                      fileUri: Path.basename(params$8.textDocument.uri),
                      pos: params$8.range.start,
                      config: ctx$1.config,
                      routeFileNames: ctx$1.routeFileNames
                    });
                var result$5 = codeActions$1 !== undefined ? codeActions$1 : null;
                var msg$10 = make$2(msg.id, undefined, Caml_option.some(result$5));
                return sendFn.contents(msg$10);
              }
              var msg$11 = make$2(msg.id, undefined, null);
              return sendFn.contents(msg$11);
          case "RescriptRelayRouterRoutes" :
              var thisModuleName = params$3._0;
              var promise$1 = getFreshModuleDepsCache();
              if (promise$1 !== undefined) {
                Caml_option.valFromOption(promise$1).then(function (res) {
                      if (res.TAG !== "Ok") {
                        return ;
                      }
                      var foundRoutes = new Set();
                      findRoutesForFile(thisModuleName, res._0, foundRoutes);
                      if (foundRoutes.size <= 0) {
                        return ;
                      }
                      var result = filterMap$1(Array.from(foundRoutes.values()), (function (routeName) {
                              var routeEntry = findRouteWithName(routeName, ctx$1.routeStructure.result);
                              if (routeEntry !== undefined) {
                                return {
                                        sourceFilePath: pathInRoutesFolder(ctx$1.config, routeEntry.sourceFile),
                                        routeName: routeName,
                                        loc: {
                                          line: routeEntry.loc.start.line,
                                          character: routeEntry.loc.start.column
                                        },
                                        routeRendererFilePath: pathInRoutesFolder(ctx$1.config, RouteName.getRouteRendererName(routeEntry.name))
                                      };
                              }
                              
                            }));
                      var msg$12 = make$2(msg.id, undefined, Caml_option.some(result));
                      sendFn.contents(msg$12);
                    });
                return ;
              } else {
                return ;
              }
          case "RescriptRelayRouterRoutesMatchingUrl" :
              var match$7 = params$3._0;
              if (match$7.length === 1) {
                var url = match$7[0];
                var urlObj = new URL(url.startsWith("http") ? url : "http://localhost" + url);
                var match$8 = ctx$1.routeStructure;
                var routesByName = match$8.routesByName;
                var routes = routeChildrenToPrintable(match$8.result).map(rawRouteToMatchable);
                var result$6 = filterMap$1(getOr(matchRoutesCli(routes, {
                                pathname: urlObj.pathname,
                                search: getOr(urlObj.search, ""),
                                hash: urlObj.hash,
                                state: urlObj.state
                              }), []), (function (matched) {
                          return routesByName[matched.route.fullName];
                        })).map(function (routeEntry) {
                      return {
                              sourceFilePath: pathInRoutesFolder(ctx$1.config, routeEntry.sourceFile),
                              routeName: RouteName.getFullRouteName(routeEntry.name),
                              loc: {
                                line: routeEntry.loc.start.line,
                                character: routeEntry.loc.start.column
                              },
                              routeRendererFilePath: pathInRoutesFolder(ctx$1.config, RouteName.getRouteRendererName(routeEntry.name) + ".res")
                            };
                    });
                var msg$12 = make$2(msg.id, undefined, Caml_option.some(result$6));
                return sendFn.contents(msg$12);
              }
              break;
            
        }
      }
      var msg$13 = make$2(msg.id, Caml_option.some(make("InvalidRequest", "Unrecognized editor request.")), undefined);
      return sendFn.contents(msg$13);
    }
    if (match$5 !== "initialize") {
      var msg$14 = make$2(msg.id, Caml_option.some(make("ServerNotInitialized", "Server not initialized.")), undefined);
      return sendFn.contents(msg$14);
    }
    if (match$5 === "initialize") {
      initialized.contents = true;
      var msg$15 = make$2(msg.id, undefined, Caml_option.some(make$1("Full", true, {
                    triggerCharacters: [
                      "\"",
                      "="
                    ]
                  }, true, true, true)));
      return sendFn.contents(msg$15);
    }
    var msg$16 = make$2(msg.id, Caml_option.some(make("InvalidRequest", "Unrecognized editor request.")), undefined);
    sendFn.contents(msg$16);
  };
  if (mode === "NodeRpc") {
    sendFn.contents = (function (prim) {
        process.send(prim);
      });
    process.on("message", onMessage);
    console.error("Starting LSP in Node RPC.");
  } else {
    var writer = new VscodeJsonrpc.StreamMessageWriter(process.stdout);
    var reader = new VscodeJsonrpc.StreamMessageReader(process.stdin);
    sendFn.contents = (function (msg) {
        writer.write(msg);
      });
    reader.listen(onMessage);
    console.error("Starting LSP in stdio mode.");
  }
  return [routeFilesWatcher];
}
/* fs Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


function wrapInOpt(str) {
  return "option<" + str + ">";
}

var protectedNames = [
  "environment",
  "pathParams",
  "queryParams",
  "location"
];

function makeSafeParamName(paramName, params) {
  var paramNames = params.map(printablePathParamToParamName);
  if (paramName.TAG === "Param") {
    var paramName$1 = paramName._0;
    if (protectedNames.includes(paramName$1)) {
      return {
              TAG: "CollisionPrevented",
              realKey: paramName$1,
              collisionProtectedKey: "param_" + paramName$1
            };
    } else {
      return {
              TAG: "Actual",
              _0: paramName$1
            };
    }
  }
  var paramName$2 = paramName._0;
  if (paramNames.includes(paramName$2) || protectedNames.includes(paramName$2)) {
    return {
            TAG: "CollisionPrevented",
            realKey: paramName$2,
            collisionProtectedKey: "queryParam_" + paramName$2
          };
  } else {
    return {
            TAG: "Actual",
            _0: paramName$2
          };
  }
}

function getSafeKey(key) {
  if (key.TAG === "Actual") {
    return key._0;
  } else {
    return key.collisionProtectedKey;
  }
}

function getOriginalKey(key) {
  if (key.TAG === "Actual") {
    return key._0;
  } else {
    return key.realKey;
  }
}

function getRouteMakerAndAssets(route) {
  var labeledArguments = route.params.map(function (param) {
        return [
                printablePathParamToParamName(param),
                printablePathParamToTypeStr(param)
              ];
      });
  var queryParamSerializers = [];
  Object.entries(route.queryParams).forEach(function (param) {
        var paramType = param[1];
        var key = makeSafeParamName({
              TAG: "QueryParam",
              _0: param[0]
            }, route.params);
        labeledArguments.push([
              getSafeKey(key),
              "option<" + QueryParams.toTypeStr(paramType) + ">=?"
            ]);
        queryParamSerializers.push([
              key,
              QueryParams.toSerializer(paramType, getSafeKey(key)),
              paramType
            ]);
      });
  var hasQueryParams = queryParamSerializers.length > 0;
  var str = {
    contents: "@inline\nlet routePattern = \"" + RoutePath.toPattern(route.path) + "\"\n\n@live\nlet makeLink = ("
  };
  var addToStr = function (s) {
    str.contents = str.contents + s;
  };
  var numLabeledArguments = labeledArguments.length;
  labeledArguments.forEach(function (param, index) {
        addToStr("~" + param[0] + ": " + param[1]);
        if ((index + 1 | 0) < numLabeledArguments) {
          return addToStr(", ");
        }
        
      });
  addToStr(") => {\n");
  var pathParamNames = route.params.map(printablePathParamToParamName);
  var pathParamsAsJsDict = "Dict.fromArray([" + pathParamNames.map(function (paramName) {
          return "(\"" + paramName + "\", (" + paramName + " :> string)->encodeURIComponent)";
        }).join(",") + "])";
  if (hasQueryParams) {
    addToStr("  open RelayRouter.Bindings\n  let queryParams = QueryParams.make()");
    queryParamSerializers.forEach(function (param) {
          var key = param[0];
          var tmp;
          var tmp$1 = param[2];
          tmp = typeof tmp$1 !== "object" || tmp$1.TAG !== "Array" ? "setParam" : "setParamArray";
          var serializerStr = "queryParams->QueryParams." + tmp + "(~key=\"" + getOriginalKey(key) + "\", ~value=" + param[1] + ")";
          addToStr("\n  switch " + getSafeKey(key) + " {\n    | None => ()\n    | Some(" + getSafeKey(key) + ") => " + serializerStr + "\n  }\n");
        });
  }
  addToStr("  RelayRouter.Bindings.generatePath(routePattern, " + pathParamsAsJsDict + ")");
  if (hasQueryParams) {
    addToStr(" ++ queryParams->QueryParams.toString");
  }
  addToStr("\n}");
  if (hasQueryParams) {
    addToStr("\n@live\nlet makeLinkFromQueryParams = (");
    route.params.forEach(function (p) {
          addToStr("~" + printablePathParamToParamName(p) + ": " + printablePathParamToTypeStr(p) + ", ");
        });
    addToStr("queryParams: queryParams) => {\n  makeLink(");
    route.params.forEach(function (p) {
          addToStr("~" + printablePathParamToParamName(p) + ", ");
        });
    Object.entries(route.queryParams).forEach(function (param) {
          var queryParamName = param[0];
          addToStr("~" + queryParamName + "=" + (
                queryParamIsOptional(param[1]) ? "?" : ""
              ) + "queryParams." + queryParamName + ", ");
        });
    addToStr(")\n}\n");
    addToStr("\n@live\nlet useMakeLinkWithPreservedPath = (): ((queryParams => queryParams) => string) => RelayRouter__Internal.useMakeLinkWithPreservedPath(~parseQueryParams, ~applyQueryParams)\n");
  }
  route.params.forEach(function (p) {
        if (p.TAG === "PrintableRegularPathParam") {
          return ;
        } else {
          return addToStr("\n\n@live\ntype pathParam_" + printablePathParamToParamName(p) + " = " + printablePathParamToTypeStr(p));
        }
      });
  return str.contents;
}

function getQueryParamTypeDefinition(route) {
  var queryParamEntries = Object.entries(route.queryParams);
  if (queryParamEntries.length <= 0) {
    return "";
  }
  var str = {
    contents: "type queryParams = {"
  };
  queryParamEntries.forEach(function (param) {
        var queryParam = param[1];
        var isOptional = queryParamIsOptional(queryParam);
        str.contents = str.contents + ("\n  " + param[0] + ": " + (
            isOptional ? "option<" : ""
          ) + QueryParams.toTypeStr(queryParam) + (
            isOptional ? ">" : ""
          ) + ",");
      });
  str.contents = str.contents + "\n}\n\n";
  return str.contents;
}

function getQueryParamAssets(route) {
  var queryParamEntries = Object.entries(route.queryParams);
  if (queryParamEntries.length <= 0) {
    return "";
  }
  var str = "";
  str = str + ("@live\nlet parseQueryParams = (search: string): queryParams => {\n  open RelayRouter.Bindings\n  let queryParams = QueryParams.parse(search)\n  {" + queryParamEntries.map(function (param) {
            var key = param[0];
            return "\n    " + key + ": queryParams->QueryParams." + queryParamToQueryParamDecoder(param[1], key);
          }).join("") + "\n  }\n}\n\n@live\nlet applyQueryParams = (\n  queryParams: RelayRouter__Bindings.QueryParams.t,\n  ~newParams: queryParams,\n) => {\n  open RelayRouter__Bindings\n\n  " + queryParamEntries.map(function (param) {
            var queryParam = param[1];
            var key = param[0];
            if (typeof queryParam === "object") {
              if (queryParam.TAG === "Array") {
                return "\n  queryParams->QueryParams.setParamArrayOpt(~key=\"" + key + "\", ~value=newParams." + key + "->Option.map(" + key + " => " + key + "->Array.map(" + key + " => " + QueryParams.toSerializer(queryParam._0, key) + ")))";
              }
              if (queryParam.required) {
                return "\n  queryParams->QueryParams.setParam(~key=\"" + key + "\", ~value=" + QueryParams.toSerializer(queryParam, "newParams." + key) + ")";
              }
              
            }
            return "\n  queryParams->QueryParams.setParamOpt(~key=\"" + key + "\", ~value=newParams." + key + "->Option.map(" + key + " => " + QueryParams.toSerializer(queryParam, key) + "))";
          }).join("") + "\n}\n\n@live\ntype useQueryParamsReturn = {\n  queryParams: queryParams,\n  setParams: (\n    ~setter: queryParams => queryParams,\n    ~onAfterParamsSet: queryParams => unit=?,\n    ~navigationMode_: RelayRouter.Types.setQueryParamsMode=?,\n    ~removeNotControlledParams: bool=?,\n    ~shallow: bool=?,\n  ) => unit\n}\n\n@live\nlet useQueryParams = (): useQueryParamsReturn => {\n  let {search} = RelayRouter.Utils.useLocation()\n  let currentQueryParams = React.useMemo(() => {\n    search->parseQueryParams\n  }, [search])\n\n  {\n    queryParams: currentQueryParams,\n    setParams: RelayRouter__Internal.useSetQueryParams(~parseQueryParams, ~applyQueryParams),\n  }\n}");
  return str;
}

var standardRecordFields = [
  {
    TAG: "KeyValue",
    _0: "environment",
    _1: "RescriptRelay.Environment.t"
  },
  {
    TAG: "KeyValue",
    _0: "location",
    _1: "RelayRouter.History.location"
  }
];

function getRecordStructureToDecodePathParams(p, paramNameOpt) {
  var paramName = paramNameOpt ;
  var str = {
    contents: ""
  };
  var match = p.params;
  if (match.length !== 0) {
    p.params.forEach(function (p) {
          var tmp;
          if (p.TAG === "PrintableRegularPathParam") {
            var pathToCustomModuleWithTypeT = p.pathToCustomModuleWithTypeT;
            if (pathToCustomModuleWithTypeT !== undefined) {
              var text = p.text;
              tmp = "->((" + text + "RawAsString: string) => (" + text + "RawAsString :> " + pathToCustomModuleWithTypeT + "))";
            } else {
              tmp = "";
            }
          } else {
            tmp = "->Obj.magic";
          }
          str.contents = str.contents + ("    " + printablePathParamToParamName(p) + ": " + paramName + "->Dict.getUnsafe(\"" + printablePathParamToParamName(p) + "\")" + tmp + ",\n");
        });
    return str.contents;
  } else {
    return str.contents;
  }
}

function getRouteParamRecordFields(route) {
  var pathParamsRecordFields = [];
  var queryParamsRecordFields = [];
  route.params.forEach(function (param) {
        pathParamsRecordFields.push([
              getSafeKey(makeSafeParamName({
                        TAG: "Param",
                        _0: printablePathParamToParamName(param)
                      }, route.params)),
              printablePathParamToTypeStr(param)
            ]);
      });
  Object.entries(route.queryParams).forEach(function (param) {
        var safeParam = makeSafeParamName({
              TAG: "QueryParam",
              _0: param[0]
            }, route.params);
        queryParamsRecordFields.push([
              getSafeKey(safeParam),
              wrapInOpt(QueryParams.toTypeStr(param[1]))
            ]);
      });
  var recordFields = standardRecordFields.slice();
  if (route.params.length > 0) {
    recordFields.push({
          TAG: "Spread",
          _0: "pathParams"
        });
  }
  if (Object.keys(route.queryParams).length > 0) {
    recordFields.push({
          TAG: "Spread",
          _0: "queryParams"
        });
  }
  return {
          pathParamsRecordFields: pathParamsRecordFields,
          queryParamsRecordFields: queryParamsRecordFields,
          allRecordFields: recordFields
        };
}

function findChildrenPathParams(route, pathParamsOpt) {
  var pathParams = pathParamsOpt !== undefined ? pathParamsOpt : ({});
  route.children.forEach(function (child) {
        child.params.forEach(function (param) {
              pathParams[param.text] = param;
            });
        findChildrenPathParams(child, pathParams);
      });
  return pathParams;
}

function getMakePrepareProps(route, returnMode) {
  var hasQueryParams = Object.keys(route.queryParams).length > 0;
  var params = route.params;
  var childParams = Object.entries(findChildrenPathParams(route, undefined));
  var str = {
    contents: "(. \n  ~environment: RescriptRelay.Environment.t,\n  ~pathParams: Dict.t<string>,\n  ~queryParams: RelayRouter.Bindings.QueryParams.t,\n  ~location: RelayRouter.History.location,\n): prepareProps => {\n"
  };
  var propsToIgnore = [
    params.length === 0 && childParams.length === 0 ? "pathParams" : undefined,
    hasQueryParams ? undefined : "queryParams"
  ];
  filterMap$1(propsToIgnore, (function (v) {
            return v;
          })).forEach(function (propName) {
        str.contents = str.contents + ("  ignore(" + propName + ")\n");
      });
  if (returnMode === "ForInlinedRouteFn") {
    str.contents = str.contents + ("  let prepareProps: Route__" + RouteName.getFullRouteName(route.name) + "_route.Internal.prepareProps = ");
  }
  str.contents = str.contents + "  {\n    environment: environment,\n\n    location: location,\n";
  if (childParams.length > 0) {
    str.contents = str.contents + "    childParams: Obj.magic(pathParams),\n";
  }
  str.contents = str.contents + getRecordStructureToDecodePathParams(route, "pathParams");
  if (hasQueryParams) {
    Object.entries(route.queryParams).forEach(function (param) {
          var safeParam = makeSafeParamName({
                TAG: "QueryParam",
                _0: param[0]
              }, route.params);
          str.contents = str.contents + ("    " + getSafeKey(safeParam) + ": queryParams->RelayRouter.Bindings.QueryParams." + queryParamToQueryParamDecoder(param[1], getOriginalKey(safeParam)));
        });
  }
  str.contents = str.contents + "  }\n";
  if (returnMode === "ForInlinedRouteFn") {
    str.contents = str.contents + "  prepareProps->unsafe_toPrepareProps\n";
  }
  str.contents = str.contents + "}";
  return str.contents;
}

function getMakeRouteKeyFn(route) {
  var match = getRouteParamRecordFields(route);
  var queryParamsRecordFields = match.queryParamsRecordFields;
  var pathParamsRecordFields = match.pathParamsRecordFields;
  return "(\n  ~pathParams: Dict.t<string>,\n  ~queryParams: RelayRouter.Bindings.QueryParams.t\n): string => {\n" + (
          pathParamsRecordFields.length === 0 ? "  ignore(pathParams)\n" : ""
        ) + (
          queryParamsRecordFields.length === 0 ? "  ignore(queryParams)\n" : ""
        ) + "\n  \"" + RouteName.getFullRouteName(route.name) + ":\"\n" + pathParamsRecordFields.map(function (param) {
                return "    ++ pathParams->Dict.get(\"" + param[0] + "\")->Option.getOr(\"\")";
              }).join("\n") + "\n" + queryParamsRecordFields.map(function (param) {
                return "    ++ queryParams->RelayRouter.Bindings.QueryParams.getParamByKey(\"" + param[0] + "\")->Option.getOr(\"\")";
              }).join("\n") + "\n}\n\n";
}

function getPathParamsTypeDefinition(route) {
  var str = {
    contents: ""
  };
  var pathParams = route.params;
  if (pathParams.length !== 0) {
    str.contents = str.contents + "@live\ntype pathParams = {\n";
    pathParams.forEach(function (p) {
          str.contents = str.contents + ("  " + printablePathParamToParamName(p) + ": " + printablePathParamToTypeStr(p) + ",\n");
        });
    str.contents = str.contents + "}\n\n";
  }
  return str.contents;
}

function getUsePathParamsHook(route) {
  var str = "";
  var match = route.params;
  if (match.length !== 0) {
    str = str + "@live\nlet usePathParams = (): option<pathParams> => {\n  let {pathname} = RelayRouter.Utils.useLocation()\n  switch RelayRouter.Internal.matchPath(routePattern, pathname) {\n  | Some({params}) => Some(Obj.magic(params))\n  | None => None\n  }\n}";
  }
  return str;
}

function getPrepareTypeDefinitions(route) {
  var str = {
    contents: ""
  };
  var childPathParams = Object.entries(findChildrenPathParams(route, undefined));
  var match = getRouteParamRecordFields(route);
  var recordFields = match.allRecordFields;
  if (childPathParams.length !== 0) {
    str.contents = str.contents + "  @live\n  type childPathParams = {\n";
    childPathParams.forEach(function (param) {
          str.contents = str.contents + ("    " + param[0] + ": option<" + printablePathParamToTypeStr(param[1]) + ">,\n");
        });
    str.contents = str.contents + "  }\n\n";
    recordFields.push({
          TAG: "KeyValue",
          _0: "childParams",
          _1: "childPathParams"
        });
  }
  str.contents = str.contents + "  @live\n  type prepareProps = {\n";
  recordFields.forEach(function (field) {
        var tmp;
        tmp = field.TAG === "Spread" ? "    ..." + field._0 + ",\n" : "    " + field._0 + ": " + field._1 + ",\n";
        str.contents = str.contents + tmp;
      });
  str.contents = str.contents + "  }\n\n";
  str.contents = str.contents + "  @live\n  type renderProps<'prepared> = {\n    childRoutes: React.element,\n    prepared: 'prepared,\n";
  recordFields.forEach(function (field) {
        var tmp;
        tmp = field.TAG === "Spread" ? "    ..." + field._0 + ",\n" : "    " + field._0 + ": " + field._1 + ",\n";
        str.contents = str.contents + tmp;
      });
  str.contents = str.contents + "  }\n\n";
  str.contents = str.contents + "  @live\n  type renderers<'prepared> = {\n    prepare: prepareProps => 'prepared,\n    prepareCode: option<(. prepareProps) => array<RelayRouter.Types.preloadAsset>>,\n    render: renderProps<'prepared> => React.element,\n  }\n";
  str.contents = str.contents + "  @live\n  let makePrepareProps = " + getMakePrepareProps(route, "ForDedicatedRouteFile").split("\n").map(function (l, index) {
          if (index === 0) {
            return l;
          } else {
            return "  " + l;
          }
        }).join("\n") + "\n\n";
  return str.contents;
}

function getPrepareAssets() {
  var str = "";
  str = str + "@obj\nexternal makeRenderer: (\n  ~prepare: Internal.prepareProps => 'prepared,\n  ~prepareCode: Internal.prepareProps => array<RelayRouter.Types.preloadAsset>=?,\n  ~render: Internal.renderProps<'prepared> => React.element,\n) => Internal.renderers<'prepared> = \"\"";
  return str;
}

function addIndentation(str, indentation) {
  return "  ".repeat(indentation) + str;
}

function getRouteDefinition(route, indentation) {
  var routeName = RouteName.getFullRouteName(route.name);
  var str = "{\n  let routeName = \"" + routeName + "\"\n  let loadRouteRenderer = () => (() => import(" + routeName + "_route_renderer.renderer))->Obj.magic->doLoadRouteRenderer(~routeName, ~loadedRouteRenderers)\n  let makePrepareProps = " + getMakePrepareProps(route, "ForInlinedRouteFn") + "\n\n  {\n    path: \"" + RoutePath.getPathSegment(route.path) + "\",\n    name: routeName,\n    chunk: \"" + RouteName.getRouteRendererName(route.name) + "\",\n    loadRouteRenderer,\n    preloadCode: (\n      ~environment: RescriptRelay.Environment.t,\n      ~pathParams: Dict.t<string>,\n      ~queryParams: RelayRouter.Bindings.QueryParams.t,\n      ~location: RelayRouter.History.location,\n    ) => preloadCode(\n      ~loadedRouteRenderers,\n      ~routeName,\n      ~loadRouteRenderer,\n      ~environment,\n      ~location,\n      ~makePrepareProps,\n      ~pathParams,\n      ~queryParams,\n    ),\n    prepare: (\n      ~environment: RescriptRelay.Environment.t,\n      ~pathParams: Dict.t<string>,\n      ~queryParams: RelayRouter.Bindings.QueryParams.t,\n      ~location: RelayRouter.History.location,\n      ~intent: RelayRouter.Types.prepareIntent,\n    ) => prepareRoute(\n      ~environment,\n      ~pathParams,\n      ~queryParams,\n      ~location,\n      ~getPrepared,\n      ~loadRouteRenderer,\n      ~makePrepareProps,\n      ~makeRouteKey=" + getMakeRouteKeyFn(route) + ",\n      ~routeName,\n      ~intent\n    ),\n    children: [" + route.children.map(function (r) {
          return getRouteDefinition(r, indentation + 1 | 0);
        }).join(",\n") + "],\n  }\n}";
  return str.split("\n").map(function (line) {
                return addIndentation(line, indentation);
              }).join("\n");
}

function routeNameAsPolyvariant(route) {
  return "#" + RouteName.getRouteName(route.name);
}

function getActiveSubRouteFn(route) {
  var elgibleChildren = route.children.filter(function (route) {
        return !RoutePath.getPathSegment(route.path).includes("/");
      });
  if (elgibleChildren.length === 0) {
    return "";
  }
  var subRouteType = "[" + elgibleChildren.map(routeNameAsPolyvariant).join(" | ") + "]";
  return "\n@live\ntype subRoute = " + subRouteType + "\n\n@live\nlet getActiveSubRoute = (location: RelayRouter.History.location): option<" + subRouteType + "> => {\n  let {pathname} = location\n  " + elgibleChildren.map(function (child, index) {
                var checkStr = "RelayRouter.Internal.matchPath(\"" + RoutePath.toPattern(child.path) + "\", pathname)->Option.isSome";
                var str = {
                  contents: ""
                };
                if (index === 0) {
                  add(str, "if ");
                } else {
                  add(str, "else if ");
                }
                add(str, checkStr + " {\n");
                add(str, "      Some(" + routeNameAsPolyvariant(child) + ")\n");
                add(str, "    } ");
                return str.contents;
              }).join("") + "else {\n    None\n  }\n}\n\n@live\nlet useActiveSubRoute = (): option<" + subRouteType + "> => {\n  let location = RelayRouter.Utils.useLocation()\n  React.useMemo(() => {\n    getActiveSubRoute(location)\n  }, [location])\n}";
}

function getActiveRouteAssets(route) {
  var str = {
    contents: ""
  };
  add(str, "@live\nlet isRouteActive = (~exact: bool=false, {pathname}: RelayRouter.History.location): bool => {\n  RelayRouter.Internal.matchPathWithOptions({\"path\": routePattern, \"end\": exact}, pathname)->Option.isSome\n}\n\n@live\nlet useIsRouteActive = (~exact=false) => {\n  let location = RelayRouter.Utils.useLocation()\n  React.useMemo(() => location->isRouteActive(~exact), (location, exact))\n}");
  add(str, getActiveSubRouteFn(route));
  return str.contents;
}
/* RescriptRelayRouterCli__Utils Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


function prettyPrintDiagnostic(lines, diagnostic, sourceFile) {
  var fileLocText = Chalk.blackBright((diagnostic.loc.start.line + 1 | 0).toString() + ":" + (diagnostic.loc.start.column + 1 | 0).toString() + "-" + (diagnostic.loc.end_.line + 1 | 0).toString() + ":" + (diagnostic.loc.end_.column + 1 | 0).toString());
  console.log(Chalk.red("Error in file:") + " " + Chalk.blueBright(sourceFile) + ":" + fileLocText);
  console.log("\n");
  lines.forEach(function (line, index) {
        if (!(index > (diagnostic.loc.start.line - 5 | 0) && index < (diagnostic.loc.end_.line + 5 | 0))) {
          return ;
        }
        var highlightOnThisLine = index >= diagnostic.loc.start.line && index <= diagnostic.loc.end_.line;
        if (highlightOnThisLine) {
          var highlightStartOffset = index === diagnostic.loc.start.line ? diagnostic.loc.start.column : 0;
          var highlightEndOffset = index === diagnostic.loc.end_.line ? diagnostic.loc.end_.column : line.length;
          var lineText = line.slice(0, highlightStartOffset) + Chalk.bold.red(line.slice(highlightStartOffset, highlightEndOffset)) + line.slice(highlightEndOffset);
          console.log("  " + Chalk.bold.red((index + 1 | 0).toString()) + " " + Chalk.blackBright("") + " " + lineText);
          return ;
        }
        console.log("  " + (index + 1 | 0).toString() + " " + Chalk.blackBright("") + " " + line);
      });
  console.log("\n  " + diagnostic.message);
}

function printDiagnostics(param, config) {
  var routeFiles = param.routeFiles;
  param.errors.forEach(function (decodeError) {
        var match = routeFiles[decodeError.routeFileName];
        if (match !== undefined) {
          prettyPrintDiagnostic(match.rawText.split("\n"), decodeError, pathInRoutesFolder$1(config, match.fileName));
          console.log("\n");
        } else {
          console.log("Internal error: Did not find \"" + decodeError.routeFileName + "\".");
        }
      });
}
/* chalk Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


function scaffoldRouteRenderers(deleteRemoved, config) {
  var match = readRouteStructure(config);
  var routeNamesDict = match[1];
  var existingRenderers = FastGlob.sync(["**/*_route_renderer.res"], {
        cwd: pathInRoutesFolder(config, undefined)
      });
  var routeNamesWithRenderers = {};
  existingRenderers.forEach(function (rendererFileName) {
        routeNamesWithRenderers[fromRendererFileName(rendererFileName)] = true;
      });
  if (deleteRemoved) {
    existingRenderers.forEach(function (rendererFileName) {
          var match = routeNamesDict[fromRendererFileName(rendererFileName)];
          if (match !== undefined) {
            return ;
          } else {
            console.log("Removing unused renderer \"" + rendererFileName + "\"");
            Fs.unlinkSync(pathInRoutesFolder(config, rendererFileName));
            return ;
          }
        });
  }
  Object.entries(routeNamesDict).forEach(function (param) {
        var routeName = param[0];
        var match = routeNamesWithRenderers[routeName];
        if (match !== undefined) {
          return ;
        } else {
          Fs$1.writeFileIfChanged(pathInRoutesFolder(config, toRendererFileName(routeName)), "let renderer = Routes." + RouteName.getFullRouteAccessPath(param[1][0].name) + ".makeRenderer(\n  ~prepare=props => {\n    ()\n  },\n  ~render=props => {\n    React.null\n  }\n)");
          console.log("Added \"" + toRendererFileName(routeName) + "\"");
          return ;
        }
      });
}

function generateRoutes(scaffoldAfter, deleteRemoved, config) {
  console.log("Generating routes...");
  var match = readRouteStructure(config);
  var routeNamesDict = match[1];
  var routes = match[0];
  var routesFile = {
    contents: "//@generated\n// This file is autogenerated, do not edit manually\n"
  };
  routes.forEach(function (route) {
        add(routesFile, printNestedRouteModules(route, 0));
      });
  Fs$1.writeFileIfChanged(pathInGeneratedFolder(config, "Routes.res"), routesFile.contents);
  var currentFilesInOutputTarget = FastGlob.sync(["Route__*_route.res"], {
        cwd: pathInGeneratedFolder(config, undefined)
      });
  currentFilesInOutputTarget.forEach(function (fileName) {
        var match = fileName.endsWith("_route.res");
        var match$1 = fileName.startsWith("Route__");
        var shouldDelete;
        if (match && match$1) {
          var routeName = fileName.slice("Route__".length).replace("_route.res", "");
          shouldDelete = isNone(routeNamesDict[routeName]);
        } else {
          shouldDelete = false;
        }
        if (shouldDelete) {
          Fs.unlinkSync(pathInGeneratedFolder(config, fileName));
          return ;
        }
        
      });
  Object.values(routeNamesDict).forEach(function (param) {
        var route = param[0];
        var assetsContent = "// @generated\n// This file is autogenerated from \`" + route.sourceFile + "\`, do not edit manually.\n" + getPathParamsTypeDefinition(route) + getQueryParamTypeDefinition(route) + "module Internal = {\n" + getPrepareTypeDefinitions(route) + "}\n\n" + getQueryParamAssets(route) + "\n\n" + getRouteMakerAndAssets(route) + "\n\n" + getActiveRouteAssets(route) + "\n\n" + getUsePathParamsHook(route) + "\n\n" + getPrepareAssets();
        Fs$1.writeFileIfChanged(pathInGeneratedFolder(config, RouteName.toGeneratedRouteModuleName(route.name) + ".res"), assetsContent);
      });
  var fileContents = "\nopen RelayRouter__Internal__DeclarationsSupport\n\nexternal unsafe_toPrepareProps: 'any => prepareProps = \"%identity\"\n\nlet loadedRouteRenderers: Map.t<string, loadedRouteRenderer> = Map.make()\n\nlet make = (~prepareDisposeTimeout=5 * 60 * 1000): array<RelayRouter.Types.route> => {\n  let {prepareRoute, getPrepared} = makePrepareAssets(~loadedRouteRenderers, ~prepareDisposeTimeout)\n\n  [\n    " + routes.map(function (route) {
          return getRouteDefinition(route, 1);
        }).join(",\n") + "\n  ]\n}";
  Fs$1.writeFileIfChanged(pathInGeneratedFolder(config, "RouteDeclarations.res"), fileContents);
  Fs$1.writeFileIfChanged(pathInGeneratedFolder(config, "RouteDeclarations.resi"), "let make: (~prepareDisposeTimeout: int=?) => array<RelayRouter.Types.route>");
  if (scaffoldAfter) {
    scaffoldRouteRenderers(deleteRemoved, config);
  }
  console.log("Done!");
}

function printRouteInfo(url, config) {
  var match = readRouteStructure(config);
  var urlObj = new URL(url.startsWith("http") ? url : "http://localhost" + url);
  var matched = getOr(matchRoutesCli(match[0].map(rawRouteToMatchable), {
            pathname: urlObj.pathname,
            search: getOr(urlObj.search, ""),
            hash: urlObj.hash,
            state: urlObj.state
          }), []);
  var matchCount = matched.length;
  if (matchCount !== 0) {
    var str = {
      contents: "URL matched " + matchCount.toString() + " route(s).\n\n===== Matched structure:\n"
    };
    var indentation = {
      contents: 0
    };
    var strEnd = {
      contents: ""
    };
    matched.forEach(function (matchedRoute, index) {
          var propsForRoute = Object.entries(matchedRoute.params).filter(function (param) {
                return matchedRoute.route.params.includes(param[0]);
              });
          str.contents = str.contents + "\n" + ("  ".repeat(indentation.contents) + "// In \"" + matchedRoute.route.sourceFile + "\"\n") + "  ".repeat(indentation.contents) + ("<" + matchedRoute.route.name + propsForRoute.map(function (param) {
                    return " " + param[0] + "=\"" + param[1] + "\"";
                  }).join("") + ">");
          if ((index + 1 | 0) !== matchCount) {
            strEnd.contents = strEnd.contents + "\n" + "  ".repeat(indentation.contents) + ("</" + matchedRoute.route.name + ">");
          }
          indentation.contents = indentation.contents + 1 | 0;
        });
    var contents = strEnd.contents.split("\n");
    console.log(str.contents + "\n" + (contents.reverse(), contents.join("\n")));
    return ;
  }
  console.log("URL did not match any routes.");
}

function init() {
  if (Config.exists()) {
    console.log("[init] Config exists, moving on...");
  } else {
    console.log("[init] Config does not exist, creating default one...");
    var path = Path.resolve(process.cwd(), "./rescriptRelayRouter.config.cjs");
    Fs.writeFileSync(path, "module.exports = " + JSON.stringify({
              routesFolderPath: "./src/routes"
            }, null, 2));
    console.log("[init] Config created at: " + path);
  }
  try {
    var config = Config.load();
    var routesJsonPath = pathInRoutesFolder(config, "routes.json");
    if (!Fs.existsSync(routesJsonPath)) {
      console.log("[init] `routes.json` does not exist, creating...");
      Fs.writeFileSync(routesJsonPath, JSON.stringify([
                {
                  path: "/",
                  name: "Root",
                  children: []
                },
                {
                  path: "*",
                  name: "FourOhFour"
                }
              ], null, 2));
      console.log("[init] Basic `routes.json` added at: " + routesJsonPath);
    }
    
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Invalid_config) {
      console.log("[init] Config existed, but was misconfigured. Re-configure it and rerun this command.");
      process.exit(0);
    } else {
      throw exn;
    }
  }
  console.log("[init] Done! You can now run the `generate -scaffold-renderers` command.");
}

function runCli(args) {
  var match = fromArray(args);
  if (match) {
    switch (match.hd) {
      case "-h" :
      case "-help" :
          console.log("Usage:\n  init                                                      | Inits the config for the router.\n\n  lsp                                                       | Starts a language server for the router.\n    [-stdio]                                                |   [-stdio] will start the LS in stdio mode. Default is Node RPC mode.\n\n  generate\n    [-scaffold-renderers] [-delete-removed] [-w, --watch]   | Generates all routing code. Run this after making changes.\n                                                            |   [-scaffold-renderers] will also run the command to scaffold \n                                                            |   route renderers.\n                                                            |   [-w, --watch] runs this command in watch mode.\n\n  scaffold-route-renderers\n    [-delete-removed]                                       | Will automatically add route renderer files for all routes that \n                                                            | do not have them. \n                                                            |   [-delete-removed] will remove any route renderer that does not \n                                                            |   have a route defined anymore.\n\n  find-route <url>                                          | Shows what routes/components will render for a specific route.\n                                                            | Example: find-route /todos/123");
          return "Done";
      case "find-route" :
          var match$1 = match.tl;
          if (match$1) {
            if (match$1.tl) {
              console.log("Unknown command. Use -help or -h to see all available commands.");
              return "Done";
            }
            var config = Config.load();
            printRouteInfo(match$1.hd, config);
            return "Done";
          }
          console.log("Unknown command. Use -help or -h to see all available commands.");
          return "Done";
      case "generate" :
          var options = match.tl;
          var scaffoldAfterGenerating = has(options, "-scaffold-renderers", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var deleteRemoved = has(options, "-delete-removed", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var shouldWatch = has(options, "-w", (function (prim0, prim1) {
                  return prim0 === prim1;
                })) || has(options, "--watch", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var config$1 = Config.load();
          ensureRouteStructure(config$1.routesFolderPath);
          var generateRoutesSafe = function () {
            try {
              return generateRoutes(scaffoldAfterGenerating, deleteRemoved, config$1);
            }
            catch (raw_e){
              var e = Caml_js_exceptions.internalToOCamlException(raw_e);
              if (e.RE_EXN_ID === Js_exn.$$Error) {
                console.error(e._1);
                return ;
              } else if (e.RE_EXN_ID === Decode_error) {
                return printDiagnostics(e._1, config$1);
              } else {
                console.log("Something went wrong generating your routes. Please check the validity of `routes.json`.");
                console.log(e);
                return ;
              }
            }
          };
          generateRoutesSafe();
          if (!shouldWatch) {
            return "Done";
          }
          console.log("Watching routes...");
          var theWatcher = Chokidar.watch(pathInRoutesFolder(config$1, "*.json")).on("change", (function (param) {
                    generateRoutesSafe();
                  })).on("unlink", (function (param) {
                  generateRoutesSafe();
                }));
          return {
                  TAG: "Watcher",
                  watchers: [theWatcher]
                };
      case "init" :
          if (match.tl) {
            console.log("Unknown command. Use -help or -h to see all available commands.");
            return "Done";
          } else {
            init();
            return "Done";
          }
      case "lsp" :
          var config$2 = Config.load();
          var mode = has(match.tl, "-stdio", (function (prim0, prim1) {
                  return prim0 === prim1;
                })) ? "Stdio" : "NodeRpc";
          var watchers = start(mode, config$2);
          return {
                  TAG: "Watcher",
                  watchers: watchers
                };
      case "scaffold-route-renderers" :
          var deleteRemoved$1 = has(match.tl, "-delete-removed", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var config$3 = Config.load();
          ensureRouteStructure(config$3.routesFolderPath);
          console.log("Scaffolding route renderers...");
          try {
            scaffoldRouteRenderers(deleteRemoved$1, config$3);
            console.log("Done!");
          }
          catch (raw_routeStructure){
            var routeStructure = Caml_js_exceptions.internalToOCamlException(raw_routeStructure);
            if (routeStructure.RE_EXN_ID === Decode_error) {
              printDiagnostics(routeStructure._1, config$3);
            } else {
              throw routeStructure;
            }
          }
          return "Done";
      default:
        console.log("Unknown command. Use -help or -h to see all available commands.");
        return "Done";
    }
  } else {
    console.log("Unknown command. Use -help or -h to see all available commands.");
    return "Done";
  }
}
/* fs Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE


var args = filterMap$1(process.argv.slice(2), (function (arg) {
        return arg;
      }));

try {
  runCli(args);
}
catch (raw_message){
  var message = Caml_js_exceptions.internalToOCamlException(raw_message);
  if (message.RE_EXN_ID === Invalid_config) {
    console.log("Error: " + message._1);
  } else {
    throw message;
  }
}

var Utils;

var Commands;
/* args Not a pure module */

export { Commands, Utils, args };
